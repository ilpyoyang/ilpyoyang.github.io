---
title: 정보처리기사 실기
author: ilpyo
date: 2024-10-10 11:33:00 +0900
categories: [Certificate]
tags: [정보처리기사]
pin: false
math: true
mermaid: true
---

수제비 정보처리기사 실기 책 내용 요약내용 + 직접적으로 시험(2020년 1회 ~ 2023년 1회))에 나왔던 문제는 기호(🔴) 표기를 해두었습니다.

## Contents
+ [1장. 요구사항 확인](#1장-요구사항-확인)
+ [2장. 데이터 입출력 구현](#2장-데이터-입출력-구현)
+ [3장. 통합구현](#3장-통합-구현)
+ [4장. 서버 프로그램 구현](#4장-서버-프로그램-구현)
+ [5장. 인터페이스 구현](#5장-인터페이스-구현)
+ [6장. 화면설계](#6장-화면설계)
+ [7장. 애플리케이션 테스트 관리](#7장-애플리케이션-테스트-관리)
+ [8장. SQL 응용](#8장-SQL-응용)
+ [9장. 소프트웨어 개발 보안 구축](#9장-소프트웨어-개발-보안-구축)
+ [10장. 프로그래밍 언어 활용](#10장-프로그래밍-언어-활용)
+ [11장. 응용 SW 기초 기술 활용](#11장-응용-sw-기초-기술-활용)
+ [12장. 제품 소프트웨어 패키징](#12장-제품-소프트웨어-패키징)
+ [13장. 기타 추가내용](#13장-기타-추가내용)

<br>

## 1장. 요구사항 확인
### 1-1. 현행 시스템 분석
**현행 시스템 파악 절차**    
구성/기능/인터페이스 파악 - 아키텍처 및 소프트웨어 구성 파악  - 하드웨어 및 네트워크 구성 파악

**TCP/IP**  
인터넷 프로토콜인 IP와 전송 조절 프로토콜 TCP. TCP는 데이터의 전달을 보증하고 보낸 순서대로 받게 해줍니다.

**소프트웨어 아키텍처**  
여러 가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부로 드러나는 특성 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체  
<U>아키텍처 명세서, 이해관계자, 관심사, 관점, 뷰, 근거</U>
+ 관심사란? 시스템에 대해 이해관계자들의 서로 다른 의견과 목표

**소프트웨어 아키텍처 4+1 뷰**  ```유논프구배```   
고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근방법
+ 유스케이스 뷰
  + ```+1```에 해당되는 부분으로 아키텍처를 도출하고 설계하는 작업을 주도하는 뷰이며, 다른 뷰를 검증하는데 사용됩니다.
+ 논리 뷰
  + 설계 모델의 추상화, 주요 설계 패키지와 서브 시스템, 클래스를 식별하는 뷰
  + 클래스와 이들 간 관계에 대한 집합을 보여주는 ```클래스 다이어그램```으로 표현
+ 프로세스 뷰
  + 런타임 시의 시스템 테스크, 스레드, 프로세스와 이들 사이의 상호작용 등의 관계를 표현하는 뷰
  + 성능이나 가용성과 같은 시스템의 비기능적인 요구상항을 고려
+ 구현 뷰 (컴포넌트 뷰)
  + 개발자 관점에서 소프트웨어 구현과 관리적인 측면을 ```컴포넌트 다이어그램```으로 표현
+ 배포 뷰
  + 물리적 노드와 구성과 상호 연결 관계를 ```배포 다이어그램```으로 표현하는 뷰

**분석 산출물**  
정보시스템 구성 현황 / 정보시스템 기능 구성도 / 인터페이스 현황 / 현황 시스템 아키텍처 구성도 / 소프트웨어 구성도 / 하드웨어 구성도 / 네트워크 구성도

**OSI 7계층**  ```아파서 티내다 피나다``` 🔴  
<U>응용, 표현, 세션, 전송, 네트워크, 데이터링크, 물리</U>

| 계층                         | 설명                                   | 프로토콜       | 전송단위 | 네트워크 장비  |
|----------------------------|--------------------------------------|------------|------|----------|
| 응용 계층 (Application Layer)  | 사용자와 네트워크 간 응용서비스 연결,데이터 생성          | HTTP, FTP  | 데이터  | 호스트      |
| 표현 계층 (Presentation Layer) | 데이터 형식 설정과 부호교환, 암/복호화               | JPEG, MPEG | 데이터  | 호스트      |
| 세션 계층 (Session Layer)      | 연결접속 및 동기제어                          | SSH, TLS   | 데이터  | 호스트      |
| 전송 계층 (Transprot Layer)    | 신뢰성 있는 통신보장, 데이터 분할과 재조립,흐름제어, 오류제어, 혼잡제어 등을 담당 | TCP, UDP   | 세그먼트 | L4 스위치   |
| 네트워크 계층 (Network Layer)    | 단말 간 데이터 전송을 위한 최적화된 경로 제공           | IP, ICMP   | 패킷   | 라우터      |
| 데이터링크 계층 (Datalink Layer)  | 인접 시스템 간 데이터 전송, 전송오류 제어, 오류검출 및 재전송 기능 제공 | 이더넷        | 프레임  | 브리지, 스위치 |
| 물리 계층 (Physical Layer) 🔴  | 0과 1 비트 정보를 회선에 보내기 위한 전기적 신호 변환     | RS-232C    | 비트   | 허브, 리피터  |

+ SSH 🔴
  + 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해주는 응용 프로그램 또는 그 프로토콜
  + 보안 접속을 통한 rsh, rcp, rlogin, rexec, telnet, ftp 등을 제공하며, IP spoofing (IP스푸핑, 아이피 위/변조 기법중 하나)을 방지하기 위한 기능을 제공
  + 기본적으로 포트는 22번
+ ICMP(Internet Control Message Protocol) 🔴🔴
  + IP 패킷을 처리할 때 발생하는 문제를 알려주는 프로토콜로 메시지 형식은 8바이트의 헤더와 가변 길이의 데이터 영역으로 분리되어 있다.
  + 수신지 도달 불가 메시지는 수신자 또는 서비스에 도달할 수 없는 호스트를 통지하는데 사용
  + ICMP 프로토콜을 사용해서 ping 유틸리티의 구현을 통해 오류가 발생했음을 알리는 기능을 수행

**미들웨어**  
분산 시스템 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이뤄질 수 있도록 제어해주는 소프트웨어
+ WAS  
  서버계층에서 애플리케이션이 동작할 수 있는 환경을 제공하고 안정적인 트랜잭션 처리와 관리, 다른 이기종 시스템과의 애플리케이션 연동을 지원하는 서버

### 1-2. 요구사항 확인
**요구사항의 분류**
1. 기능적 요구사항  
   시스템이 제공하는 기능, 서비스에 대한 요구사항
2. 비기능적 요구사항    
   시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항

**요구사항 개발 프로세스**  ```도분명확```  
<U>요구사항 도출 - 요구사항 분석 - 요구사항 명세 - 요구사항 확인</U>
+ ```도출```: <U>인터뷰, 설문조사, 브레인스토밍, 워크숍</U>
+ ```분석```: 자료 흐름 지향 분석, 객체지향 분석
+ ```명세```: 자연어에 의한 방법, 정형화 기법 사용방법
+ ```확인```: <U>동료검토, 워크스루(회의전 배포), 인스펙션(전문가)</U>

**요구사항 분석**  
요구사항 분류, 개념 모델링, 요구사항 할당, 요구사항 협상, 정형분석

**요구사항 확인기법**  
<U>요구사항 검토, 프로토타이핑, 모델 검증, 인수 테스트</U>

**비용산정 모델의 분류**
1. 하향식 비용산정 모델  
   <U>전문가 판단, 델파이 기법</U>
2. 상향식 비용산정 모델  
   <U>LoC(Line of Code), Man Month, COCOMO, Putnam, 기능점수 모형</U>
  + ```Man Month``` 프로젝트 인원과 관련없이 한 사람이 프로젝트를 할 때 걸리는 시간
  + ```COCOMO(COnstructive COst MOdel)``` 보헴이 제안한 모델 유형으로 프로그램 규모에 따라 비용을 산정 - 단순형, 중간형, 임베디드형
  + ```Putnam``` 소프트웨어 개발 주기의 단계별로 요구할 인력의 분포를 가정하는 모형
  + ```기능점수 모형``` 요구기능을 증가시키는 인자별로 가중치를 부여하여 기능 점수를 계산해 비용을 선정하는 방식

### 1-3. 분석 모델 확인하기
**분석클래스의 스테레오 타입**  
경계, 엔티티, 제어의 각각의 스테레오 타입 알아두기

**분석 모델의 시스템화 타당성 분석 프로세스**  
타당성 검토의견 컬럼 추가 - 타당성 검토의견 작성 - 타당성 분석 결과 검증 - 타당성 분석 결과 확인 및 배포/공유

**UML(Unified Modeling Language)**
> 기능) 유스케이스 다이어그램<br>
> 구조/정적) 클래스 다이어그램<br>
> 동적) 상태/순서 다이어그램

객체지향 소프트웨어 개발과정에서 산출물을 명세화,시각화, 문서화할 시 사용되는 모델링기술과 방법론을 통합해 만든 표준화된 범용 모델링 언어
+ ```사물```, ```관계```, ```다이어그램``` 🔴

UML 관계
+ Association 연관관계
  + Association 연관관계
    + 방향성 없는 실선 표기
  + Direct 직접연관관계
    + 참조하는 측만 인지
  + Aggregation 집합 연산 관계 🔴
    + 하나의 사물이 다른 사물에 포함되어 있는 관계 표현
    + 하나의 객체에 여러 개의 독립적인 객체들이 구성되는 관계
    + 포함되는 쪽(Part, 부분)에서 포함하는 쪽(Whole, 전체)으로 속이 빈 마름모를 연결하여 표현
    + 전체 소멸 시 부분은 사용가능
  + Composition 합성 연관 관계 🔴
    + 전체 소멸 시 부분도 소멸
+ Dependency 의존관계
  + Extend 확장의존관계
    + 클랜스 변화가 타클래스에 영향
    + 참조를 유지하지 않음
    + 선택적 확장하는 관계
  + Include 포함의존관계
    + 클래스 변화가 타클래스에 영향
    + 참조를 유지하지 않음
    + 반드시 포함하는 관계
+ Generalization 일반화 관계 🔴
  + 일반화 관계는 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현
  + 일반적인 개념을 부모(상위)라고 하고, 구체적인 자식 개념을 자식(하위)이라고 함
  + 구체적(하위)인 사물에서 일반적(상위)인 사물 쪽으로 속이 빈 화살표를 연결하여 표현
  + 일반화 관계는 다른 의미로 상속 관계라고 함
+ Realization 실체화 관계
  + 인터페이스와 구현클래스 관계
  + 부모의 불완전 행동을 자식이 구현

UML 다이어그램 종류
> Use Case, Activity, Sequence, Collaboration, Class, Component, Deployment 다이어그램

+ 클래스 다이어그램 🔴🔴
  + 속성, 메서드를 포함하는 다이어그램
  + 시스템에서 사용되는 객체 타입을 정의하고, 그들 간의 존재하는 정적인 관계를 다양한 방식으로 표현한 다이어그램
+ 유스케이스 다이어그램
  + 요구사항들 가운데서 기능적인 요구사항을 유스케이스랑 단위로 표현하고 액터와 시스템의 관계를 표현한 다이어그램
+ 패키지 다이어그램
  + 폴더 모양의 패키지와 점선으로 표시된 의존관계, <<Import>>라는 스테레오 타입 표기를 통해 패키지 다이어그램인지를 파악할 수 있음

| 클래스 다이어그램 |컴포넌트 다이어그램 | 배포 다이어그램 |
|------------|----------|----------|
| ![class_diagram.png](/assets/post_images/cs/class_diagram.png)           |![component_diagram.gif](/assets/post_images/cs/component_diagram.gif)          |![uml_diagram.png](/assets/post_images/cs/uml_diagram.png)|

| 유스케이스 다이어그램 | 패키지 다이어그램 | 
|-------------|-----------|
| ![usecase_diagram.svg](/assets/post_images/cs/usecase_diagram.svg)            | ![package_diagram.png](/assets/post_images/cs/package_diagram.png)          |

인터페이스 🔴
+ 클래스와 같은 기타 모델 요소 또는 컴포넌트가 구현해야하는 오퍼레이션 세트를 정의하는 모델 요소
+ 클래스와 같은 UML에 표현되는 사물의 하나로, 클래스나 컴포넌트의 동작을 모아놓은 것이며, 외부적으로 가시화되는 행동을 표현하며, 단독으로 사용하는 경우는 없고 인터페이스 구현을 위한 클래스 또는 컴포넌트와 함께 사용

<br>

****
**용어정리**

| 용어                                     | 설명                                                                                        |
|----------------------------------------|-------------------------------------------------------------------------------------------|
| IPS(Intrusion Prevention System)       | 네트워크에 대한 공격이나 침입을 실시간으로 차단하고, 유해 트래픽에 대한 조치를 능동적으로 처리하는 시스템                               |
| 라우터                                    | OSI 3계층에서 사용하는 네트워크 장비로 스위치를 서로 연결하여 네트워크 간 비용 소모가 최적화된 라우팅 경로를 설정하고, 결정된 경로를 따라 트래픽을 전달  |
| 보안 컨테이너                                | 저작권 관리에서 원본을 안전하게 유통하기 위한 전자적 보안 장치                                                       |
| 클리어링 하우스                               | 저작권 관리에서 키 관리 및 라이선스 발급 관리를 수행합니다.                                                        |
| 스레드                                    | 프로세스의 실행부분을 담당하는 실행의 기본단위                                                                 |
| 프로세스                                   | 운영체제가 관리하는 실행단위로 프로세서에 의해 처리되는 PCB를 가진 시스템 프로그램                                           |
| 프로토콜                                   | 서로 다른 시스템에 있는 두 개체 간의 데이터 교환을 위해 원활히 하기 위한 일련의 통신규약                                       |
| SSO 🔴                                   | 한 번의 시스템 인증을 통하여 여러 정보시스템에 재인증 절차 없이 접근할 수 있는 통합 로그인 기술                                   |
| 백본망                                    | 다양한 네트워크를 상호연결하는 컴퓨터 네트워크의 일부로서, 각기 다른 LAN이나 부분망 간의 정보를 교환하기 위해 경로를 제공하는 망                |
| 라우터                                    | 3계층 데이터 패킷을 발신지에서 목적지까지 전달하기 위해 최적의 경로를 지정하고 이 경로를 따라 데이터 패킷을 다음 장치로 전달하는 네트워크 장비         |
| 스위치                                    | 2계층 장비로서,동일 네트워크 내에서 출발지에 들어온 데이터 프레임을 목적지 MAC 주소 기반으로 빠르게 전달하는 네트워크 장비                   |
| 게이트웨이                                  | 컴퓨터 네트워크에서 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 네트워크 장비                              |
| 가비지 컬랙션, GC                            | 메모리 관리 기법의 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요 없게 된 영역을 해제하는 기능                            |
| 트랜잭션                                   | 인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야하는 특성이자, 데이터베이스에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본단위 |
| OPS(Operations Per Second)             | 초당 처리되는 연산능력을 가리키는 말로 컴퓨터의 성능을 수치로 나타낼 때 사용되는 단위                                          |
| 프로토타이핑                                 | 사용자가 요구한 주요 기능을 프로토타입으로 구현하여 사용자의 비드백을 통해 개선, 보완하여 완성 소프트웨어를 만들어가는 과정                     |
| 상호운용성                                  | 다른 목적을 지닌 2개 이상의 시스템들이 상호 간 정보 및 서비스를 교환하면서 효과적으로 운용될 수 있는 시스템의 능력                        |
| KDSI(Kilo Delivered Source Instruction) | 전체 소스 코드 라인 수를 1,000라인으로 묶은 단위                                                            |
| 유스케이스                                  | 시스템이 액터에게 제공해야 하는 기능으로 시스템 요구사항이자, 사용자 입장에서 바라본 시스템의 기능                                   |

<br><br>

## 2장. 데이터 입출력 구현
### 2-1. 논리 데이터 저장소 확인
**DB 설계 절차** ```개논물```   
요구사항 분석 - 개념적 설계 - 논리적 설계 - 물리적 설계 - 구현
+ 개념적 설계 🔴
  + 요구사항 명세서를 기반으로 개념적 데이터 모델을 표현하며 E-R 다이어그램으로 표현할 수 있음
+ 논리적 설계 🔴
  + 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행
+ 물리적 설계 🔴
  + 특정 DBMS의 특성 및 성능을 고려하고 데이터베이스의 저장 구조로 변환하는 과정으로 결과가 나오는 명세서는 테이블 정의서 등이 있음

**논리 데이터 모델링**  
데이터베이스 설계 프로세스의 기초 설계 단계로 비즈니스정보의 구조 규칙을 명확하게 표현할 수 있는 기법  
개념 모델로부터 업무영역의 업무 데이터 및 규칙을 구체적으로 표현한 모델
```
학생(학번, 교수번호(FK), 이름, 주소)
교수(교수번호, 이름, 전공과목)
```
+ 논리 데이터 모델링 특성 - ```정규화```, ```포용성```, ```완전성```, ```독립성```
+ 논리 데이터 모델링 속성 - ```개체```, ```속성```, ```관계```
+ 개체-관계(E-R) 모델 다이어그램 기호
  + 개체(네모), 관계(마름모), 속성(타원), 다중값 속성(이중타원), 관계-속성 연결(선)

**정규화 이상현상**  ```삽삭갱``` 🔴
+ ```삽입이상``` 정보 저장시 해당 정보의 불필요한 세부정보를 입력해야 하는 경우
+ ```삭제이상``` 정보 삭제시 원치 않는 다른 정보가 같이 삭제되는 경우 🔴
+ ```갱신이상``` 중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우

**정규화**  ```원부이 결다조```  
관계형 데이터베이스의 설계에서 중복을 최소화하여 테이블을 구조화하는 프로세스. 보이스-코드 정규형까지가 기본 정규형에 속합니다.
+ 슈퍼키: 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합, ```유일성```만 만족 🔴
+ 후보키: 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합, 기본키가 될 수 있는 후보들. ```유일성```과 ```최소성```을 동시에 만족 🔴
+ 기본키: 후보키 들 중에서 하나로 최소성과 유일성을 만족하는 속성, NULL과 중복값을 가질 수 없다.
+ 대체키: 기본키로 지정한 것 외의 후보키들
+ 결정자: x가 Y에 대응한다고 할 때, X는 결정자, Y는 종속자.

| 단계               | 조건                        | 예시                                                 |
|------------------|---------------------------|----------------------------------------------------|
| 1정규형(1NF)        | 원자값으로 구성                  | 이메일 컬럼에 이메일이 두 개 있는 경우 분리                          |
| 2정규형(2NF)        | 부분 함수 종속 제거(완전 함수적 종속 관계) | 종속관계 내에 존재하는 다른 종속 관계 분리                           |
| 3정규형(3NF)        | 이행함수 종속 제거                | A->B 그리고 B->C 관계가 있는 테이블의 분리                       |
| 보이스-코드 정규형(BCNF) | 결정자 함수 이면서 후보키가 아닌 것 제외   | 결정자이지만 후보키가 아닌 속성이 있는 경우 분리 (아래 사례설명 참조)           |
| 4정규형(4NF)        | 다치(중앙값) 속성 제거             | 개발자마다 자격증, 언어라는 속성을 가지고 있을 때, 다중값 종속을 제거           |
| 5정규형(5NF)        | 조인 종속성 제거                 | 4정규화에서 자격증, 언어 테이블도 분리해 조인을 했을 때 원래 상태로 복원이 가능하게 함 |

결정자와 후보키에 대하여  
예를 들어, 학생 테이블에서 학번과 이름이 속성으로 있다고 가정해봅시다. 학번은 후보키가 될 수 있으며, 학번을 통해 학생의 이름을 결정할 수 있습니다. 그러나 이름은 후보키가 아니며, 다른 결정자(예: 전화번호)를 결정할 수도 있습니다.

결정자이지만 후보키가 아닌 속성이 있는 경우에 대해서  
기본키가 학번과 과목명인 경우에 이를 가지고 교수명에 영향을 줄 수 있습니다. 하지만 교수명 자체는 과목명에 영향을 주는 결정자가 되지만 후보키가 될 수 없는 상태입니다. 따라서 이는 보이스-코드 정규형에 위배되는 상황입니다.

**함수적 종속**
+ 완전 함수적 종속(Full Functional Dependency) 🔴
  + 기본키에만 종속되며, 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속
  + id 값을 알아야만 식별이 가능하다.
+ 부분 함수적 종속(Partial Functional Dependency) 🔴
  + 릴레이션에 종속자가 기본키가 아닌 다른 속성에 종속되거나 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 속성 중 일부에만 종속되는 경우
  + 기본키가 두 개로 되어 있을 경우, 하나만 알아도 식별이 가능하다.
+ 이행적 함수적 종속(Transitive Functional Dependency) 🔴
  + X->Y, X->Z일 때, X->Z인 경우의 종속

### 2-2. 물리 데이터 저장소 설계
**물리 데이터 모델링**  
논리모델을 적용하고자 하는 기술에 맞도록 상세화하는 과정
```sql
CREATE TABLE STUDENT
(
    s_id INT PRIMARY KEY,
    p_id INT REFERENCES PROFESSER(p_id),
    name VARCHAR(20),
    addr VARCHAR(100)
)
```
CONSTRANINT  
테이블에 올바른 데이터만 입력받고 잘못된 데이터는 들어오지 못하게 하는 컬럼마다 정하는 규칙

**데이터베이스 파일 구조**
+ 순차 방법
  + 레코드들의 물리적 순서가 레코드들의 논리적인 순서와 같게 순차적으로 저장하는 방법
+ 인덱스 방법
  + 인덱스가 가리키는 주소를 따라 원하는 레코드에 접근할 수 있도록 하는 방법
+ 해싱 접근 방법
  + 킷값을 해시 함수에 대입시켜 계산한 결과를 주소로 사용하여 레코드에 접근하게 할 수 있는 방법

**물리데이터 저장소 구성**
1. 제약조건 설계 - 참조무결성 제약조건  
   릴레이션들 사이에 대해 참조의 일관성을 보장하기 위한 조건
  + 제한(연산거절), 연쇄(일괄삭제), 널 값(Null처리)
2. 인덱스 🔴   
   검색연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터 구조로 데이터베이스에서 <키값, 주소> 형태의 자료구조
  + 적용기준: 분포도 10~15%
  + 인덱스가 걸려있는 컬럼은 ```HAVING```절 사용시 인덱스 미사용
  + ```CREATE [UNIQUE] INDEX 인덱스명 ON 테이블명(컬럼명1, 컬럼명2, ...)``` 🔴
3. 뷰
  + 뷰의 속성 ```REPLACE```, ```FORCE```, ```NOFORCE```, ```WITH CHECK OPTION```, ```WITH READ ONLY```
4. 클러스터  
   대상이 되는 범위(모집단)의 요소를 몇 개 모은 단위체로 인덱스를 사용하기에 넓은 분포도를 가진 경우에 사용합니다.
5. 파티션  
   파티셔닝을 하면 성능향상, 가용성 향상, 백업 가능, 경합 감소의 장점이 있습니다.    
   <U>레인지 파티셔닝 / 해시 파티셔닝 / 리스트 파티셔닝 / 컴포지트 파티셔닝</U>
+ 레인지 파티셔닝 - 연속적인 숫자나 날짜를 기준으로 하는 파티셔닝 기법
+ 해시 파티셔닝 - 파티션 키의 해시 함수 값에 의한 파티셔닝 기법
+ 리스트 파티셔닝 - 특정 파티션에 저장될 데이터에 대한 명시적 제어가 가능한 파티셔닝 기법
+ 컴포지트 파티셔닝 - 범위분할 이후에 해시함수를 적용하여 재분할 하는 파티셔닝 기법

### 2-3. 데이터 조작 프로시저 작성
**데이터 조작 프로시저**  
SQL을 이용해서 생성된 데이터를 조작  
PL/SQL은 표준 SQL을 기본으로 오라클에서 개발한 데이터 조작 언어입니다.
```sql
CREATE OR REPLACE PROCEDURE INPUT_EMP
(
    p_name IN VARCHAR2,
    p_empno IN NUMBER
)
IS
BEGIN
    INSERT INTO EMPLOYEE(NAME, EMPNO)
        VALUES(p_name, p_empno);
COMMIT;
END;
EXEC INPUT_EMP('홍길동','31512');
```
연결절차
+ 드라이버 로딩 - 데이터베이스 연결 - 쿼리 전달 - 결과 수신

**데이터 조작 프로시저 테스트**  
DBMS_OUTPUT 패키지를 사용합니다. 메시지를 버퍼에 저장하고 버퍼로부터 메시지를 읽어오기 위한 인터페이스를 제공하는 패키지입니다.    
실행을 위해서는 ```SET SERVEROUTPUT ON;```하고 실행하고자 하는 프로시저를 ```EXECUTE```합니다.
```sql
CREATE OR REPLACE PROCEDURE INPUT_EMP
(
    p_name IN VARCHAR2,
    p_empno IN NUMBER
)
IS
BEGIN
    DBMS_OUTPUT.ENABLE; -- 데이터 조작 프로시저 테스트
    INSERT INTO EMPLOYEE(NAME, EMPNO)
        VALUES(p_name, p_empno);
    DBMS_OUTPUT.PUT_LINE(p_name); -- 데이터 조작 프로시저 테스트, 마지막에 EOL 문자를 추가   
COMMIT;
END;
EXEC INPUT_EMP('홍길동','31512');
```
PL/SQL 오류 발생시 ```SHOW ERRORS``` 명령어로 오류내용을 확인할 수 있습니다.

### 2-4. 데이터 조작 프로시저 최적화
**옵티마이저**  
개발자가 작성한 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리경로를 생성해주는 데이터베이스 핵심모듈이며, 이 때 최적의 처리경로는 ```실행경로```라고 합니다.
+ 규칙기반 옵티마이저(RBO, Rule Based Optimizer)
  + 통계정보가 없는 상태에서 사전 등록된 규칙에 따라 질의 실행 계획을 선택하는 옵티마이저
+ 비용기반 옵티마이저(CBO, Cost Based Optimizer)
  + 통계 정보로부터 모든 접근 경로를 고려한 질의실행 계획을 선택하는 옵티마이저

**힌트**  
SQL 성능 개선의 핵심 부분으로 옵티마이저 실행 계획을 원하는대로 변경할 수 있게 합니다.
```sql
SELECT /*+ RULE */ ENAME, SAL
FROM EMP
WHERE EMPNO > 9000;
```
주요 옵티마이저 힌트

| 힌트                           | 설명                    |
|------------------------------|-----------------------|
| ```/*+ RULE */```            | 규칙 기반 접근 방식을 사용하도록 지정 |
| ```/*+ CHOOSE */```          | 오라클 옵티마이저 디폴트 값으로 |
| ```/*+ INDEX(데이블 인덱스명) */``` | 지정된 인덱스를 강제적으로 사용 |
| ```/*+ USE_HASH(테이블명) */```  | 지정된 테이블들의 조인이 Hash Join 형식으로 일어나도록 유도 |
| ```/*+ USE_MARGE(테이블명) */``` | 지정된 테이블들의 조인이 Sort Merge 형식으로 일어나도록 유도 |
| ```/*+ USE_NL(테이블명) */```    | 지정된 테이블들의 조인이 Nested Loop 형식으로 일어나도록 유도 |

**기타 SQL**
1. 컬럼 추가
```sql
ALTER TABLE 테이블명 ADD 컬럼명 데이터타입 [제약조건]; 🔴
```
2. 컬럼 수정
```sql
ALTER TABLE 테이블명 MODIFY 컬럼명 데이터타입 [제약조건]; 🔴
```
3. 컬럼 삭제
```sql
ALTER TABLE 테이블명 DROP 컬럼명 데이터타입 [제약조건]; 🔴
```

<br>

****
**용어정리**

| 용어                                      | 설명                                                                            |
|-----------------------------------------|-------------------------------------------------------------------------------|
| 개념모델                                    | 주제 영역과 핵심 데이터 집합 간의 관계를 정의하는 모델, 엔티티와 관계 위조의 모델                               |
| 릴레이션                                    | 행과 열로 구성된 테이블                                                                 |
| 관심사                                     | 시스템에 대해 이해관계자들의 서로 다른 의견과 목표                                                  |
| 관점                                      | 개별 뷰를 개발할 때 토대가 되는 패턴이나 양식                                                    |
| 뷰                                       | 서로 관련 있는 관심사들의 집합이라는 관점에서 전체 시스템을 표현                                          |
| 온라인 트랜잭션 처리(OLTP) 시스템                   | 기술 환경 정의를 위한 기초 자료 조사 항목은 시스템 구축 형태, 사용자 수, 트랜잭션 수 등이 있음                      |
| 요구사항 명세                                 | 체계적으로 검토, 평가, 승인될 수 있는 문서를 작성하는 것                                             |
| 반정규화(비정규화) 🔴                             | 정규화된 엔티티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법     |
| DDL(Data Definition Language)           | 데이터를 정의하는 언어로 테이블과 같은 데이터 구조를 정의하는 데 사용되는 명령어                                 |
| DML(Data Manipulation Language)         | 데이터베이스에 저장된 자료들을 입력, 수정, 삭제, 조회하는 언어 (SELECT, INSERT, DELETE, UPDATE)         |
| 디스크 스트라이핑                               | 성능 향상을 위해 데이터 1개 이상의 디스크 드라이브에 저장하여 드라이브를 병렬로 사용할 수 있는 기술                     |
| APM(Application Performance Monitoring) | 안정적인 시스템 운영을 위해 부하량, 접속자 파악 및 장애진단 등을 목적으로 하는 성능 모니터링 도구                      |
| 선택도(Selectivity)                        | 전체 대상 레코드 중에서 특정 조건에 의해 선택될 것으로 예상되는 레코드 비율                                   |
| 힌트                                      | 실행하려 하는 SQL문에 사전에 정보를 주어서 SQL문 실행에 빠른 결과를 가져오는 효과를 만드는 문법                     |
| 해시 조인                                   | 해싱 함수 기법을 활용하여 조인을 수행하는 방식                                                    |
| 정렬 합병 조인                                | 조인의 대상범위가 넓을 경우 발생하는 임의 접근을 줄이기 위한 경우나 연결고리에 마땅한 인덱스가 존재하지 않을 경우 해결하기 위한 조인방법 |
| 중첩 반복 조인                                | 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 Row를 결합하여 원하는 결과를 조합하는 방식                 |

**관계 데이터 모델 구성요소** ```튜카속차```

| 구성요소           | 설명                                    |
|----------------|---------------------------------------|
| 릴레이션           | 행과 열로 구성된 테이블                         |
| 튜플             | 관계형 데이터베이스의 행                         |
| 속성(Attribute)  | 관계형 데이터베이스의 열                         |
| 카디널리티 🔴       | 튜플의 개수                                |
| 차수(Degree) 🔴  | 애트리뷰트의 수                              |
| 스키마            | 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조 |
| 인스턴스           | 정의된 스키마에 따라 생성된 테이블에 실제 저장된 데이터의 집합   |

**데이터 모델의 구성요소**  ```연구제```
+ 연산(Operation) 🔴
  + 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세
+ 구조(Structure) 🔴
  + 논리적으로 표현된 개체 타입 간의 관계
+ 제약조건(Constraint)
  + 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약조건

**DDL의 대상** ```도스테뷰인```
+ 도메인
  + 하나의 속성이 가질 수 있는 원자값들의 집합
  + 속성의 데이터 타입과 크기, 제약조건 등의 정보
+ 스키마 🔴
  + 데이터베이스 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조
  + 외부/개념/내부 3계층으로 구성
+ 테이블
  + 데이터 저장 공간
+ 뷰
  + 하나 이상의 물리 테이블에서 유도되는 가상의 테이블
+ 인덱스
  + 검색을 빠르게 하기 위한 데이터 구조

**스키마의 종류**
+ 외부 스키마 🔴
  + 사용자나 개발자의 관점에서 필요로 하는 데이터베이스의 논리적 구조
  + 사용자 뷰를 나타냄
  + 서브 스키마로 불림
+ 개념 스키마 🔴
  + 데이터베이스의 전체적인 논리적인 구조
  + 전체적인 뷰
+ 내부 스키마 🔴
  + 물리적 저장장치의 관점에서 보는 데이터베이스 구조
  + 실제로 데이텅베이스에 저장될 레코드 형식을 정의하고 저장데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 표현

<br><br>

## 3장. 통합 구현
### 3-1. 연계 데이터 구성
**연계 요구사항 분석**  
분석기법 - 인터뷰, 체크리스트, 설문지, 델파이기법, 브레인스토밍
분석 참고문서 - 코드 정의서, 테이블 정의서, 응용 프로그램 구성도, 시스템 구성도
+ 연계 시스템은 송신 시스템과 수신 시스템으로 구성할 수 있으며, 연계 방식에 따라 중계 서버를 둘 수 있습니다.

### 3-2. 연계 매커니즘 구성
**연계 매커니즘**  
응용 소프트웨어와 연계 대상 모듈 간의 데이터 연계 시 요구사항을 고려한 연계방법과 주기를 설계하기 위한 흐름

**연계 방식 분류**  
직접 연계 - DB 링크, DB 연결, API/OPEN API, JDBC, 하이퍼링크  
간접 연계 - <U>연계 솔루션(EAI), Web Service/ESB, 소켓</U>

### 3-3. 내외부 연계 모듈 구현
**EAI(Enterprise Application Integration)** 🔴  
기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간의 정보 전달, 연계, 통합을 가능하게 해주는 솔루션  
시스템 통합에 상용하는 솔루션으로 구축 유형에는 Point to Point, Hub & Spoke, Message Bus가 있습니다.

**ESB(Enterprise Service Bus)**  
기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간을 하나의 시스템으로 관리 운영할 수 있도록 서비스 중심의 통합을 지향하는 아키텍처 또는 기술  
버스를 중심으로 각각 프로토콜이 호환 가능하도록 애플리케이션의 통합을 느슨한 결합 방식으로 지원하는 방식

**웹 서비스 방식**  
<U>SOAP, UDDI, WSDL</U>

<img src="https://private-user-images.githubusercontent.com/67682215/333507520-f2787746-cfc6-4f15-ad9a-5e08c945a1d3.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTY1Mzg2ODMsIm5iZiI6MTcxNjUzODM4MywicGF0aCI6Ii82NzY4MjIxNS8zMzM1MDc1MjAtZjI3ODc3NDYtY2ZjNi00ZjE1LWFkOWEtNWUwOGM5NDVhMWQzLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA1MjQlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNTI0VDA4MTMwM1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTY2YWJlOThmYzNmYWQ2OTljMzJiZGJjZWNhNjg3YmZmMzQ0MTExZDRhMDZhZGM5YmIxZTJjOGQxMjVhZWNmNmImWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.gUOLPB2hy5ijkaQpGqzTJ5lu2E5AiLebUW_2qHqAJ_4" />

+ SOAP(Simple Object Access Protocol) 🔴
  + HTTP, HTTPS, SMTP 등을 사용하여 XML 기반의 메시지를 네트워크 상태에서 교환하는 프로토콜
+ UDDI(Universal Description, Discovery and Integration)
  + 웹 서비스에 대한 정보인 WSDL을 등록하고 검색하기 위한 저장소로 공개적으로 접근, 검색이 가능한 레지스토리
+ WSDL(Web Service Description Language) 🔴
  + 웹 서비스명, 제공 위치, 메시지 포맷, 프로토콜 정보 및 웹 서비스에 대한 상세 정보를 기술한 XML 형식으로 구현된 언어
  + SOAP와 XML 스키마와 결합하여 인터넷상에 웹 서비스를 제공하기 위해 사용
  + WSDL은 서비스 인터페이스와 서비스 구현으로 구성

<br>

****
**용어정리**

| 용어                                    | 설명                                                                                                                                   |
|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|
| 인스턴스                                  | OOP에서 해당 클래스의 구조로 컴퓨터 저장 공간에서 할당된 실체                                                                                                 |
| 오브젝트                                  | 저장공간에 할당되어 값을 가지거나 식별자에 의해 참조되는 공간                                                                                                   |
| 느슨한 결합(Loosely Coupled)               | 특정 서비스를 변경하더라도 연결된 다른 서비스에는 영향을 주지 않는 유연한 구조                                                                                         |
| REST(Representational State Transfer) | HTTP URI를 통해 자원을 명시하고, HTTP 메서드를 통해 해당 자원에 대한 생성, 조회, 갱신, 삭제 등의 명령을 적용하는 것을 의미                                                       |
| JSON 🔴                                 | 비동기 브라우저/서버 통신을 위해 '속성-값 쌍', '키-값 쌍'으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷<br> AJAX에서 많이 사용되고 XML을 대체하는 주요 데이터 포맷 |

<br><br>

## 4장. 서버 프로그램 구현
### 4-1. 개발환경 구축
**개발환경 구축**  
빌드 도구, 구현 도구, 테스트 도구, 형상 관리 도구
+ 웹 서버
  + HTTP를 이용한 요청/응단을 처리
  + 웹 상의 정적 콘텐츠를 처리
  + Apache 웹 서버, ISS 웹 서버, Nginx 등
+ 웹 애플리케이션 서버
  + 동적 콘텐츠(Servlet, JSP)를 처리하기 위해 사용
  + Tomcat, Resin 등
+ 데이터베이스 서버
+ 파일 서버

**형상관리** 🔴  
형상관리는 소프트웨어 개발을 위한 전체 과정에서 모든 항목의 변경 사항을 관리하기 위한 활동

형상관리 절차  
<U>형상 식별 - 형상 통제 - 형상 감사 - 형상 기록</U>
+ 형상 식별
  + 형상관리 대상을 정의 및 식별하는 활동
  + 추적성 부여를 위해 ID와 관리번호를 부어
  + 변경 관리 이슈 발생시 ID와 관리번호를 이용하여 처리
+ 형상 통제 🔴
  + 형성 항목의 버전 관리를 위한 형상통제위원회 운영
  + 변경요구 관리, 변경제어, 형상 관리 등 통제 지원
+ 형상 감사
  + 소프트웨어 베이스라인의 무결성 평가
  + 베이스라인 변경시 요구사항과 일치 여부 검토
+ 형상 기록
  + 소프트웨어 형상 및 변경관리에 대한 각종 수행결과를 기록
  + 형상결과 보고서 작성

### 4-2. 공통 모듈 구현
**공통 모듈 구현**
+ 모듈
  + 크게 독립된 하나의 소프트웨어 또는 하드웨어 단위를 지칭
+ 공통 모듈
  + 전체 프로그램 중에서 특정 기능을 처리할 수 있는 실행 코드. 자체적으로 컴파일이 가능하고 다른 프로그램에서 제사용이 가능

**소프트웨어 모듈 응집도**  
모듈의 독립성을 나타내는 개념으로 결합도는 낮게, 응집도는 높게, 모듈의 크기는 작게 만들어야 합니다.
+ 응집도 ```우논시절 통순기``` 🔴
  + 정보 은닉의 확장 개념으로 하나의 모듈은 하나의 기능을 수행하는 것을 의미
  + 응집도가 가장 높은 것은 ```기능적 응집도```

| 유형              | 설명                                                                                    |
|-----------------|---------------------------------------------------------------------------------------|
| 우연적 응집도         | 모듈 내부의 각 구성요소가 연관이 없는 경우                                                              |
| 논리적 응집도         | 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우                                        |
| 시간적 응집도         | 연관된 기능이라기보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우                                       |
| 절차적 응집도 🔴      | 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우, 입출력 간 연관성은 없으나 순서에 따라 수행될 필요가 있음 |
| 통신적(교환적) 응집도 🔴 | 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우                                            |
| 순차적 응집도         | 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용할 경우                                                 |
| 기능적 응집도 🔴      | 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우, 모든 기능들이 연관되어 있는 것, 그룹화                              |

+ 결합도 ```내공 외제 스자``` 🔴
  + 외부 모듈과의 연관도 또는 상호의존성
  + 결합도가 가장 낮은 것은 ```자료 결합도```

| 유형         | 설명                                                           |
|------------|--------------------------------------------------------------|
| 내용 결합도     | 다른 모듈 내부에 있는 변수가 기능을 다른 모듈에서 사용하는 경우                         |
| 공통 결합도     | 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우 |
| 외부 결합도     | 두 개의 모듈이 외부에서 도입된 데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스를 공유할 경우     |
| 제어 결합도 🔴    | 단순 처리할 대상인 값만 절달되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우       |
| 스탬프 결합도    | 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우                          |
| 자료 결합도     | 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 간의 상호작용이 일어나는 경우             |

**팬인(Fan-In) 및 팬아웃(Fan-Out)** 🔴🔴  
팬인과 팬아웃으로 시스템 복잡도를 측정할 수 있습니다.
+ 팬인: 어떤 모듈을 제어하는 모듈의 수
+ 팬아웃: 어떤 모듈에 의해 제어되는 모듈의 수

**공통 모듈 테스트**  
공통 모듈 테스트는 화이트 박스 기법을 사용합니다. + ```JUnit``` 🔴   
<U>화이트 박스 테스트 / 메서드 기반 테스트 / 화면 기반 테스트 / 테스트 드라이버 & 테스트 스텁</U>
+ 화이트 박스 테스트
  + 프로그램의 로직을 이해하고, 내부 구조와 동작을 검사하는 소프트웨어 테스트 방식
+ 테스트 드라이버 & 테스트 스텁
  + 기능을 테스트할 수 있는 화면 또는 하위 모듈 구현이 구현되지 않은 경우 테스트 드라이버 & 테스트 스텁로 통합 테스트 수행
  + 드라이버는 하위 모듈은 있지만 상위 모듈이 없는 경우
  + 스텁은 상위 모듈은 있지만 하위 모듈이 없는 경우 🔴

<br>

### 4-3. 서버 프로그램 구현
백엔드와 프로트엔드   
VO, SQL문, DAO, Sevice, Controller 순서대로 구현(?)

<br>

### 4-4. 배치 프로그램 구현
배치 프로그램은 사용자와의 상호작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄 처리하는 방법입니다.  
이벤트 배치, 온디맨드 배치, 정기 배치

**배치 스케줄러**  
일괄 처리를 위해 주기적으로 발생시키거나 반복적으로 발생하는 작업을 지원하는 도구  
배치는 대용량 처리를 지원하고 쿼츠는 다양한 스케쥴 기능을 지원하기 때문에 혼합 사용합니다.
+ 스프링 배치
  + 스프링 프레임워크의 DI, AOP, 서비스 추상화 등 스프릥 프레임워크의 3대 요소를 모두 사용할 수 있는 대용량 처리를 제공하는 스케줄러
+ 쿼츠 스케줄러
  + 스프링 프레임워크에 플러그인되어 수행하는 작업과 실행 스케줄을 정의하는 트리거를 분리하여 유연성을 제공하는 오픈 소스 기반 스케줄러
  + 작업과 실행 스케줄을 정의하는 트리거를 분리하여 유연성을 제공하는 오픈소스 기반 스케줄러
+ Cron 표현식(크론 표현식)  ```초분시일 월요연```
  + ```* /10 * * * *``` 매 10분마다 실행
  + ```0 0 12 * * *``` 매일 12시에 실행

<br>

****
**용어정리**

| 용어                        | 설명                                                                  |
|---------------------------|---------------------------------------------------------------------|
| 테이블 정의서                   | 논리 및 물리 모델링 과정에서 작성하는 설계 산출물로 테이블을 구성하는 칼럼들의 특성, 인덱스, 업무 규칙을 문서화한 것 |
| 인터페이스 정의서                 | 송신 시스템과 수신 시스템 간의 인터페이스 방식, 주기 등을 기록한 현황을 작성                        |
| JVM(Java Virtual Machine) | 시스템 메모리를 관리하면서 자바 기반 애플리케이션을 위해 이식 가능한 실행 환경을 제공하는 소프트웨어            |
| 컨테이너                      | JSP와 서블릿을 실행시킬 수 있는 소프트웨어                                           |
| 소켓                        | 연결을 생성하여 포트를 할당하고, 클라이언트의 요청을 연결하여 통신하는 기법                          |
| 베이스라인                     | 개발 과정의 각 단계의 산출물을 검토, 평가, 조정, 처리 등 변화를 통제하는 시점의 기준                  |

<br><br>

## 5장. 인터페이스 구현
### 5-1. 인터페이스 설계 확인
**인터페이스 설계서**  
인터페이스 설계서는 이 기종 시스템 및 컴포넌트 간 데이터 교환 및 처리를 위해 각 시스템의 교환되는 데이터, 업무, 송수신 주체 등이 정의된 문서

[공통 모듈 연계방법](/cs/2023/04/13/CS_certificate.html#3-3-내외부-연계-모듈-구현) 참조

**EAI** ```포허메하```  
기업 내부의 이기종 응용 모듈 간 통합, 기업 내부망  
핵심기술: ```어댑터```, ```브로커```, ```메시지 큐```
+ 포인트 투 포인트 🔴
  + 1:1 단순 통합방식
+ 허브 앤 스포크 🔴
  + 단일 접점의 허브 시스템을 통해 데이터를 전송하는 중앙 집중식 방식
+ 메시지 버스
  + 애플리케이션 사이 미들웨어를 두어 연계하는 미들웨어 통합 방식
  + 뛰어난 확장성과 대용량 데이터 처리 가능
+ 하이브리드
  + 그룹 내는 허브 앤 스포크 방식을 사용하고 그룹 간에는 메시지 버스 방식을 사용하는 통합 방식

**ESB**  
기업 간의 서비스 교환을 위해 표준 API로 통합, 느슨한 결합 방식으로 기업 외부 채널망

인터페이스 의미 파악과 인터페이스 기능 확인을 통해 데이터 표준을 확인할 수 있습니다.

<br>

### 5-2. 인터페이스 기능 구현
**컴포넌트 명세서**  
컴포넌트의 개요, 내부 클래스의 동작, 인터페이스를 통해 외부와 통신하는 명세를 정의

**인터페이스 명세서**  
컴포넌트 명세서에 명시된 인터페이스 클래스의 세부적인 조건 및 기능을 명시한 명세서

**시큐어 코딩 가이드**  
입력 데이터 검증 및 표현 / 보안기능 / 시간 및 상태 / 에러 처리 / 코드 오류 / 캡슐화 / API 오용

**데이터베이스 암호화**

암호화 알고리즘
+ 대칭 키 암호화 알고리즘: 암복호화에 같은 알고리즘을 사용
  + SEED, ARIA 128/192/256
+ 비대칭 키 알고리즘: 공개키와 비밀키를 가지고 있어야 하는 알고리즘
  + RSA, ECC, ECDSA
+ 해시 암호화 알고리즘: 해시값으로 원래 입력값을 찾아낼 수 없는 일방향성 특성을 지닌 알고리즘
  + SHA-256/384/512, HAS-160

암호화 기법
+ API 방식, Plug-In 방식, Hybrid 방식

민감한 정보를 통신 채널을 통해 전송 시에는 반드시 암복호화 과정을 거쳐야 하고, ```IPSec```, ```SSL/TLS``` 등 보안 채널을 활용하여 전송합니다.
+ IPSec(IP Security)  🔴
  + IP 계층에서 무결성과 인증을 보장하는 인증헤더와 기밀성을 보장하는 암호화를 이용한 IP 보안 프로토콜
  + 주요 프로토콜
    + 인증(AH) 프로토콜
    + 암호화(ESP) 프로토콜
    + 기 관리(IKE) 프로토콜
+ SSL/TLS
  + 응용계층과 TCP/IP 계층 사이에서 웹 데이터 암호화 및 전송 시 기밀성을 보장하는 공개키 기간의 보안 프로토콜

**TKIP, 임시 키 무결성 프로토콜 (Temporal Key Integrity Protocol)** 🔴   
무선 라우터에서 WEP 암호화를 대체하기 위해 만들어진 보안 프로토콜 최적의 보안을 위해서는 AES를 사용하게 되어있지만, 일부 장치와의 호환성을 위해 사용하는 임시 키 무결성 프로토콜

<br>

### 5-3. 인터페이스 구현 검증
**인터페이스 구현 검증 도구**  
xUnit, STAP, FitNesse, Selenium, watir

인터페이스의 동작이 잘 진행되는지 지속적으로 확인하기 위해서는 애플리케이션 모니터링 툴(APM, Application Performance Management)을 사용하여 동작상태를 감시할 수 있습니다.

<br>

****
**용어정리**

| 용어                                        | 설명                                                                                           |
|-------------------------------------------|----------------------------------------------------------------------------------------------|
| FTP(File Transfer Protocol)               | TCP/IP 프로토콜을 가지고 서버와 클라이언트 사이의 파일을 전송하기 위한 프로토콜                                              |
| 어댑터                                       | 다양한 패키지 애플리케이션 및 기업에서 자체적으로 개발한 애플리케이션을 연결하는 EAI의 핵심 장치                                      |
| 브로커                                       | 시스템 상호 간 데이터가 전송될 때, 데이터 포맷과 코드를 변환하는 솔루션                                                    |
| 메시지 큐                                     | 비동기 메시지를 사용하는 다른 응용 프로그램 사이에서 데이터를 송수신 하는 기술                                                 |
| MyBatis                                   | 객체지향 언어인 자바의 관계형 DB 프로그래밍을 좀 더 쉽게 할 수 있게 도와주는 개발 프레임워크                                       |
| iBatis                                    | SQL 기반 데이터베이스와 자바, 닷넷, 루비 등을 연결시켜주는 역할을 하는 개발 프레임워크                                          |
| 컴포넌트                                      | 특정한 기능을 수행하기 위해 독립적으로 개발되어 보급되는 잘 정의되는 인터페이스를 가지며 다른 부품과 조립되어 응용시스템을 구축하기 위해 사용되는 소프트웨어 프로그램 |
| AJAX(Asynchronous Java Script and XML) 🔴 | 자바스크립트를 사용한 비동기 통신기술로, 클라이언트와 서버 간의 XML 데이터를 주고 받는 기술                                        |
| 직렬화                                       | 데이터 구조나 오브젝트를 다른 컴퓨터 환경으로 저장하고 재구성할 수 있는 포맷으로 변환하는 과정                                        |
| XML 🔴                                    | W3C에서 개발되었고, 웹 브라우저 간 호환이 되지 않는 문제와 SGML의 복잡함을 해결하기 위해 개발된 다목적 마크업 언어                        |
| ICP(Inter-Process Communication) 🔴         | 공유메모리, 소켓, 세마포어, 메시지 큐 등 프로세스 간 통신하는 기술                                                      |

<br><br>

## 6장 화면설계
### 6-1. UI 요구사항 확인
**UI(User Interface)**  
사용자와 시스템 사이에서 의사소통할 수 있도록 고안된 물리적, 가상의 매개체  
UX(사용자 결험)은 UI를 포함하고 있습니다.
+ CLI(Command Line Interface)
  + 명령어를 텍스트로 입력하여 조작하는 사용자 인터페이스
+ GUI(Graphical User Interface 🔴
  + 그래픽 환경을 기반으로 한 마우스나 전자펜을 사용하는 사용자 인터페이스
+ NUI(Natural User Interface) 🔴
  + 키보드나 마우스 없이 신체 부위를 이용하는 사용자 인터페이스
+ OUI(Organic User Interface)
  + 현실에 존재하는 모든 사물이 입출력장치로 변화할 수 있는 사용자 인터페이스

UI 설계원칙   
직관성 / 유효성 / 학습성 / 유연성
+ 직관성 🔴
  + 누구나 쉽게 이해하고 쉽게 사용할 수 있어야 함
+ 유효성 🔴
  + 정확하고 완벽하게 사용자의 목표가 달성될 수 있도록 제작
+ 학습성
  + 초보와 숙련자 모두가 쉽게 배우고 사용할 수 있게 제작
+ 유연성
  + 사용자의 인터랙션을 최대한 포용하고, 실수를 방지할 수 있도록 제작

**UI 화면 설계 구분**
+ 와이어 프레임
  + 이해관계자들과의 화면구성을 협의하거나 서비스의 간락한 흐름을 공유하기 위해 화면 단위의 레이아웃을 설계하는 작업
+ 스토리보드
  + 정책, 프로세스, 콘텐츠 구성, 와이어프레임, 기능정의, 데이터베이스 연동 등 서비스 구축을 위한 모든 정보가 담겨 있는 설계 산출물
+ 프로토타입
  + 정적인 화면으로 설계된 와이어 프레임 또는 스토리보드에 동적 효과를 적용하여 실제 구현한 것처럼 시뮬레이션 할 수 있는 모델

<br>

### 6-2. UI 설계
UI 흐름설계, UI 상세설계, UI 설계도구

<br>

****
**용어정리**

| 용어      | 설명                                                           |
|---------|--------------------------------------------------------------|
| 인터렉션    | 입출력장치를 매개로 디지털 시스템과 사람이 주고받는 일련의 의사소통 과정                     |
| UX      | 제품과 시스템, 서비스 등을 사용자가 직/간접적으로 경험하면서 느끼고 생각하는 총체적 경험           |
| 프로파일    | 어떤 시스템을 일정 범위 내에서 한정적으로 특징 지우는 그룹화된 값                        |
| 사용성 테스트 | 사용자가 직접 제품을 사용하면서 미리 작성된 시나리오에 맞춰 과제를 수행한 후, 질문에 답하도록 하는 테스트 |
| 액터      | 시스템의 외부에 있고 시스템과 상호작용을 하는 사람 또는 시스템                          |
| 유스케이스   | 시스템이 액터에게 제공해야 하는 기능으로 시스템 요구사항이자, 사용자 입장에서 바라본 시스템의 기능      |
| 목업      | 실제 제품이 나오기 전 만드는 모형                                          |

<br><br>

## 7장 애플리케이션 테스트 관리
### 7-1. 애플리케이션 테스트 케이스 설계
**소프트웨어 테스트**  
개발된 응용 애플리케이션이나 시스템이 사용자가 요구하는 기능과 성능, 사용성, 안정성을 만족하는지 확인하고, 노출되지 않은 숨어있는 소프트웨어의 결함을 찾아내는 활동
+ 프로그램 실행 여부에 따른 분류
  + 정적 테스트 (정적분석도구 테스트) - 동료검토, 워크스루, 인스펙션 🔴
  + 동적 테스트 - 화이트박스 테스트, 블랙박스 테스트
+ 테스트 기법에 따른 분류
  + 화이트박스 테스트 / 블랙박스 테스트
+ 테스트 시각에 따른 분류
  + 검증 / 확인
+ 테스트 목적에 따른 분류
  + 회복 / 안전 / 강도 / 구조 / 회귀 / 병행
+ 테스트 종류에 따른 분류
  + 명세 기반 테스트 / 구조 기반 테스트 / 경험 기반 테스트

**소스 품질 분석도구**
+ Static Analysis 🔴
  + 원시 코드를 분석하여 잠재적인 오류를 분석하며, 코딩 표준, 런타임 오류 등을 검증한다.
+ Dynamic Analysis 🔴
  + 프로그램 수행 중 발생하는 오류를 검출한다. 메모리 릭, 동기화 오류를 분석하는 것이 가능하다.


**화이트박스 테스트**  
구조 테스트라고도 하며, 내부 로직을 보면서 하는 테스트
+ 구문 커버리지, 결정 커버리지, 조건 커버리지, 변경 조건/결정 커버리지, 다중 조건 커버리지 테스트 등
+ [공통모듈 테스트](/cs/2023/04/13/CS_certificate.html#4-2-공통-모듈-구현)에서 사용하는 테스트
+ 문장(구문) 커버리지 🔴
  + 최소 한 번은 모든 문장 수행
+ 결정(분기) 커버리지 🔴
  + 각 분기의 결정 포인트 내의 전체 조건식이 적어도 한 번은 참과 거짓의 결과를 수행해야 하기 때문에 첫 번째 분기문도 참, 거짓이 한 번씩 와야하고, 두 번째 분기문도 참, 거짓이 한 번씩 와야 함
  + 결정 검증 기준이라고도 함. 조건별 True/False일 때 수행
+ 조건 커버리지 🔴
  + 전체 조건식에 상관없이 개별 조건식의 True/False에 대해 수행

**블랙박스 테스트**  ```동경결상유분페```  🔴🔴
프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트로 명세 기반 테스트라고도 함
+ 동등 분할 테스트 🔴
  + 입력 데이터의 영역을 유사한 도메인별로 유효 값/무효 값을 그룹핑하여 대표 값 테스트 케이스를 도출하여 테스트하는 기법
+ 경계 값 분석 테스트 🔴🔴
  + 등가분할 후 경계 값 부분에서 오류 발생 확률이 높기에 경계값을 포함하여 테스트 케이스에 설계하는 기법
+ 원인-결과 그래프 테스트 🔴
  + 그래프를 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트하는 기법
+ 결정 테이블 테스트
  + 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트하는 기법
+ 상태전이 테스트
  + 테스트 대상/시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트 기법
+ 유스케이스 테스트
  + 시스템이 실제 사용되는 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행하는 테스트 기법
+ 분류트리 테스트
  + SW 일부 또는 전체를 트리구조로 표현하여 테스트 케이스를 설계하여 테스트하는 기법
+ 페어와이즈 테스트
  + Test data 값들 간에 최소한 한 번씩을 조합하는 방식이며, 이는 커버해야 할 기능적 범위를 모든 조합에 비해 상대적으로 적은 양의 테스트 세트를 구성하기 위한 테스트 기법

**검증과 확인**
+ 검증(Verification)
  + 소프트웨어 과정을 테스하고 개발자 혹은 시험자의 시각으로 소프트웨어가 명세화된 기능을 올바로 수행하는지 알아보는 과정
+ 확인(Validation)
  + 소프트웨어 결과를 테스트, 사용자 시작으로 올바른 소프트웨어가 개발되었는지 입증하는 과정

**테스트 오라클**  
테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참 값을 입력하여 비교하는 기법
+ 참 오라클
  + 모든 입력값에 대하여 기대하는 결과를 생성하므로써 발생된 오류를 모두 검출할 수 있는 오라클
+ 샘플링 오라클 🔴
  + 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클
+ 휴리스틱 오라클
  + 샘플링 오라클을 개선한 오라클로, 특정 입력값에 대하여 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱으로 처리하는 오라클
+ 일관성 검사 오라클
  + 애플리케이션 변경이 있을 때 수행 전과 후의 결과값이 동일한지 확인하는 오라클

**테스트 레벨**      
단위 테스트 - 통합 테스트 - 시스템 테스트 - 인수 테스트 🔴 (V 다이어그램)
+ 단위 테스트 🔴
  + 사용자 요구사항에 대한 단위모듈, 서브루틴 등을 테스트
+ 통합 테스트 🔴
  + 단위 테스트를 통과한 모듈 사이의 인터페이스, 통합된 컴포넌트 간의 상호작용을 검증하는 테스트 단계
+ 시스템 테스트
  + 통합된 단위 시스템의 기능이 시스템에서 정상적으로 수행되는지를 검증하는 테스트 단계
+ 인수 테스트
  + 계약상의 요구사항이 만족하였는지 확인하기 위한 테스트
  + 알파 테스트 🔴
    + 선택된 사용자(회사 내의 다른 사용자 또는 실제 사용자)가 개발자 환경에서 통제된 상태로 개발자와 함꼐 수행하는 인수테스트
    + 새로운 제품 개발 과정에서 이루어지는 첫 번째 테스트.
    + 즉, 시제품이 운영되는 동안의 신제품 연구와 개발 과정 단계에서 초기 작동의 결과를 평가하는 수단이며 개발 회사 내부에서 이루어지는 테스트로서 단위 테스트, 구성 테스트, 시스템 테스트 등을 포함
  + 베타 테스트 🔴
    + 실제 환경에서 일정 수의 사용자에게 대상 소프트웨어를 사용하게 하고 피드백을 받는 인수 테스트
    + 하드웨어나 소프트웨어의 개발 단계에서 상용화하기 전에 실시하는 제품 검사 작업. 제품의 결함 여부, 제품으로서의 가치 등을 평가하기 위해 실시
    + 선발된 잠재 고객으로 하여금 일정 기간 무료로 사용하게 한 후에 나타난 여러 가지 오류를 수정, 보완한다. 공식적인 제품으로 발매하기 이전에 최종적으로 실시하는 검사 작업

**테스트 시나리오**  
테스트 수행을 위한 여러 테스트 케이스의 집합으로서 테스트 케이스의 동작 순서를 기술한 문서이며 테스트를 위한 절차를 명세한 문서

<br>

### 7-2. 애플리케이션 통합 테스트
**통합테스트**  
애플리케이션 통합 테스트는 소프트웨어 각 모듈 간의 인터페이스 관련 오류 및 결함을 찾아내기 위한 체계적인 테스트 기법
+ 빅뱅 테스트
  + 모든 모듈을 동시에 통합 후 테스트 수행
  + 테스트 드라이버/스텁 없이 실제 모듈로 진행
  + 단시간 테스트 가능, 작은 시스템에 유리
  + 모든 모듈 개발 후 가능
+ 상향식 테스트
  + 최하위 모듈에서 점진적으로 진행
  + 테스트 드라이버 필요 🔴
  + 장애 위치 파악이 쉽지만 중요 모듈은 마지막에 테스트하게 될 가능성 높음
+ 하향식 테스트
  + 최상위 모듈부터 하위 모듈을 통합하면서 테스트
  + 테스트 스텁 필요
  + 장애 위치 파악이 쉽지만, 많은 스텁이 필요

**테스트 하네스**  
애플리케이션 컴포넌트 및 모듈을 테스트하는 환경의 일부분으로 테스트를 지원하기 위한 코드와 데이터를 말하며, 단위 또는 모듈 테스트에 사용하기 위해 코드 개발자가 작성
+ 테스트 드라이버
  + 테스트 대상 하위 모듈을 호출하고, 파라미터를 전달하고 모듈 테스트 수행 후의 결과를 도출하는 등 상향식 테스트에 필요
+ 테스트 스텁
  + 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로 하향식 테스트에 필요
+ 테스트 슈트
  + 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
+ 테스트 케이스
  + 입력값, 실행조건, 기대 결과 등의 집합
+ 테스트 스크립트
  + 자동화된 테스트 실행 절차에 대한 명세
+ 목 오브젝트
  + 사용자의 행위를 조건부로 사전에 입력해 두면, 그 상황에 예정된 행위를 수행하는 객체

**테스트 커버리지 유형**  
테스트 케이스에 의해 수행되는 소프트웨어의 테스트 범위를 측정하는 테스트 품질 측정 기준이며, 테스트의 정확성과 신뢰성을 향상시키는 역할을 합니다.
+ 기능 기반 커버리지, 라인 커버리지, 코드 커버리지

**코드 커버리지 유형**  
구조 테스트 유형과 동일합니다.
+ 구문 커버리지
  + 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지, 구문 실행 개수로 계산
+ 결정 커버리지
  + 프로그램 내의 전체 결정문이 적어도 한 번은 참과 거짓의 결과를 수행하는 커버리지
+ 조건 커버리지
  + 결정 명령문 내의 각 조건이 적어도 한 번은 참과 거짓의 결과가 되도록 수행하는 커버리지
+ 조건/결정 커버리지
  + 전체 조건식 뿐만 아니라 개별 조건식도 참 한 번, 거짓 한 번 결과가 되도록 수행하는 커버리지
+ 변경 조건/결정 커버리지
  + 각 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상시킨 커버리지
+ 다중 조건 커버리지
  + 결정 조건 내 모든 개발 조건식의 모든 가능한 조합을 100% 보장하는 커버리지

<br>

### 7-3. 애플리케이션 성능 개선
**데이터베이스 관련 성능저하 원인**  
데이터베이스 락, 불필요한 데이터베이스 패치, 연결 누수, 부적적한 커넥션 풀 크기, commit 관련

**클린코드**  
잘 작성되어 가독성이 높고, 단순하며, 의존성을 줄이고, 중복을 최소화하여 깔끔하게 잘 정리된 코드

<br>

****
**용어정리**

| 용어                                         | 설명                                                                                                          |
|--------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| 동료검토                                       | 2~3명이 진행하는 리뷰의 형태로 요구사항 명세서 작성자가 요구사항 명세서를 설명하고, 이해관계자들이 설명을 들으면서 결함을 발견하는 형태로 진행하는 검토 기법                   |
| 워크스루                                       | 검토 자료를 회의 전에 배포해서 사전검토한 후 짧은 시간동안 회의를 진행하는 형태로 리뷰를 통해 오류를 검출하고 문서화하는 기법                                     |
| 인스펙션                                       | 소프트웨어 요구, 설계, 원시 코드 등의 저작자 외의 다른 전문가 또는 팀이 검사하여 오류를 찾아내는 공식적 검토 기법                                          |
| V모델                                        | SW 생명주기 각 단계별로 개발자 관점에서의 공정 과정상 검증과 사용자 관점에서의 최종 산출물에 대한 확인을 지원하기 위한 테스트 모델                                 |
| VLAN                                       | 논리적으로 분할된 스위치 네트워크나 가상 기능을 가진 LAN 스위치 또는 ATM 스위치를 사용해서 물리적인 배신에 구애받지 않고 브로드캐스트 패킷이 전달되는 범위를 임의로 나누는 네트워크 기술 |
| 깊이-우선                                      | 루트 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법                                                             |
| 너비-우선                                      | 루트 노트에서 시작해서 인접한 노드를 먼저 탐색하는 방법                                                                             |
| 스텁                                         | 모듈 및 모든 하위 컴포넌트를 대신하는 더미 모듈로 하위 모듈의 반환 값만 전달하면 됨                                                            |
| 드라이버                                       | 상위 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈                                                                          |
| 페르소나                                       | 잠재적 사용자의 다양한 목적과 관찰된 행동 패턴을 응집시켜 놓은 가상의 사용자                                                                 |
| LDAP(Lightweight Directory Access Protocol) | TCP/IP 위에서 조직화되고 비슷한 특성을 가진 객체들의 모임인 디렉토리 서비스를 조회하고 수정하는 응용 프로토콜                                            |
| 스크립트                                       | 컴파일 하지 않고도 실행할 수 있는 프로그램                                                                                    |
| Ramp-up load                               | 한계점의 측정을 목적으로 낮은 수준의 부하부터 높은 수준의 부하까지 예상 트래픽을 꾸준히 증가시키며 진행하는 부하 테스트                                         |

<br><br>

## 8장. SQL 응용
### 8-1. 절차적 SQL 작성하기
**프로시저**  
절차형 SQL을 활용하여 특정 기능을 수행할 수 있는 트랜잭션 언어  
선언부(DECLARE), 시작/종료부(BEGIN/END), 제어부(CONTROL), SQL, 예외부(EXCEPTION), 설명부(TRANSACTION)
```sql
CREATE PROCEDURE SALES_CLOSING
(V_CLOSING_DATE IN CHAR(8))
IS
V_SALSE_TOT_AMT NUMBER := 0;

BEGIN

IF V_CLOSING_DATE < "20000101"
SET
    V_CLOSING_DATE < "20200101";
END IF;

SELECT SUM(SALES_AMT)
    INTO V_SALES_TOT_AMT
    FROM SALES_LIST_T   
WHERE SALES_DATE = V_CLOSING_DATE;

EXCEPTION
WHEN NO_DATA_FOUND
SET V_SALES_TOT_AMT = 0;

    INSERT INTO
SALES_CLOSED_T
(SALES_DATE,
 SALES_TOT_AMT)
VALUES (V_CLOSING_DATE,
        V_SALES_TOT_AMT);

COMMIT;
END;
```
```sql
EXECUTE SALES_CLOSING('20170425');
```

**사용자 정의함수**  
DBMS에서 제공하는 공통적 함수 이외에 사용자가 직접 정의하고 작성  
프로시저와 달리 설명부 대신 ```반환부(RETURN)```을 두어 사용자 정의함수 호출한 쿼리에 반환하는 단일값을 정의합니다.

**트리거**  
특정 테이블에 삽입, 수정, 삭제 등의 데이터 변경 이벤트가 발생하면 DBMS에서 자동적으로 실행되도록 구현된 프로그램입니다.  
프로시저와 달리 ```설명부(TRANSACTION)```가 없습니다. 그리고 중간에 ```EVENT```가 추가된 형태입니다.
+ 트리거 작성시 유의사항
  + TCL 사용불가
    + COMMIT, ROLLBACK 사용시 컴파일 에러 발생
  + 오류에 주의

<br>

### 8-2. 응용 SQL 작성하기
**집계 함수**  
여러 행 또는 테이블 전체 행으로부터 하나의 결괏값을 반환하는 함수
+ COUNT, SUM, AVG, MAX, MIN, STDDEV(표준편차), VARIAN(분산)

**그룹함수**  
테이블의 전체 행을 하나 이상의 컬럼을 기준으로 컬럼 값에 따라 그룹화하여 그룹별로 결과를 출력하는 함수
+ ROLLUP
  + 지정된 컬럼의 소계 등 중간 집계 값을 산출하기 위한 그룹 함수
+ CUBE
  + 모든 값의 다차원 집계를 생성
+ GROUPING SETS
  + 집계 대상 컬럼들에 대한 개별 집계를 구할 수 있으며, 컬럼 순서와 무관하게 결과를 얻을 수 있습니다.

**윈도함수**  
데이터베이스를 사용한 온라인 분석 처리 용도로 사용하기 위해서 표준 SQL에 추가된 함수, OLAP
+ 순위함수
  + RANK, DENSE_RANK(동일 순위 동일하게 부여), ROW_NUMBER
+ 행순서 함수
  + FIRST_VALUE, LAST_VALUE, LAG, LEAD
+ 그룹 내 비율 함수
  + RATIO_TO_REPORT
  + PERCENT_RANK

**데이터 제어어(DCL, Data Control Language)**  
데이터베이스 관리자가 데이터 보안, 무결성 유지, 병행 제어, 회복을 위해 관리자(DBA)가 사용하는 제어용 언어
+ GRANT 🔴
  + 특정 사용자에게 권한을 부여하는 데이터베이스 명령어
```sql
GRANT 권한 ON 테이블 TO 사용자 [WITH 권한 옵션];
```
+ REVOKE
```sql
REVOKE 권한 ON 테이블 TO 사용자 [CASCADE CONSTRAINTS];
```

<br>

****
**용어정리**

| 용어                                 | 설명                                                                                 |
|------------------------------------|------------------------------------------------------------------------------------|
| TRUNCATE                           | 데이터가 하나도 없이 테이블 구조만 남은 최초 테이블이 만들어진 상태로 되돌아가도록 하는 명령                               |
| 살충제 패러독스 🔴                        | 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못했다는 소프트웨어 테스트 원리                              |
| 오류-부재의 궤변                          | 요구사항을 충족시켜주지 못한다면, 결함이 없다고 해도 품질이 높다고 볼 수 없다는 소프트웨어 테스트 원리                         |
| 워크스루                               | 정적 테스트의 유형으로 검토 요청 발생시 요구사항, 소스 코드, 테스트 유형으로 진행하는 비정형적 테스트                         |
| 인스펙션                               | 정적 테스트의 유형으로 개발단계별 산출물 검토를 위한 공식적인 검토방법                                            |
| 회귀 테스트(Regression) 🔴                        | 변경 또는 수정된 코드에 대하여 새로운 결함 발견 여부를 평가하는 테스트로 유지보수 시 많이 사용되는 테스트                       |
| 구조 기반 테스트                          | 소프트웨어 내부 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트 기법                                       |
| 인수 테스트                             | 테스트 레벨 중 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트 단계                                          |
| 통합 테스트                             | 소프트웨어 각 모듈 간의 인터페이스 관련 오류 및 결함을 찾아내기 위한 체계적인 테스트 기법                                |
| 목 오브젝트                             | 테스트 장치 구성요소 중 하나로 사용자의 행위를 조건부로 사전에 입력해 두면, 그 상황에 예정된 행위를 수행하는 객체                  |
| OLAP(OnLine Analytical Processing) | 의사결정 지원 시스템으로 사용자가 동일한 데이터를 여러 기준을 이용하는 다양한 방식으로 바라보면서 다차원 데이터 분석을 할 수 있도록 도와주는 기술 |

****
**소프트웨어 테스트 원리**
+ 테스팅은 결함이 존재함을 밝히는 것
+ 완벽한 테스팅은 불가능
+ 개발 초기에 테스팅 시작
+ 결함집중
+ 살충제 패러독스
+ 테스팅은 정황에 의존적
+ 오류-부재의 궤변

<br><br>

## 9장. 소프트웨어 개발 보안 구축
### 9-1. 소프트웨어 개발 보안 설계
**SW 개발 보안**  
요구사항 명세 - 설계 - 구현 - 테스트 - 유지보수
+ 기밀성 Confidentiality
  + 인가되지 않은 개인 혹은 시스템 접근에 따른 정보 공개 및 노출을 차단하는 특성
+ 가용성 Availability 🔴
  + 권한을 가진 사용자나 애플리케이션이 원하는 서비스를 지속 사용할 수 있도록 보장하는 특정
+ 무결성 Integrity
  + 정당한 방법을 따르지 않고 데이터가 변경될 수 없으며, 데이터의 정확성 및 완전성과 고의/악의로 변경되거나 훼손 또는 파괴되지 않음을 보장하는 특성


**보안 솔루션**
+ SIEM(Security information and event management) 🔴
  + 머신러닝 기술을 이용하여 IT 시스템에서 발생하는 대량의 로그를 통합관리 및 분석하여 사전에 위협에 대응하는 보안 솔루션이다.
  + 서로 다른 기종의 보안솔루션 로그 및 이벤트를 중앙에서 통합 수집하여 분석할 수 있으며, 네트워크 상태의 monitoring 및 이상징후를 미리 감지할 수 있다.
  + 다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합하여 관리하는 보안 솔루션으로, 방화벽, IDS, IPS, 웹 방화벽, VPN 등에서 발생한 로그 및 보안 이벤트를 통합하여 관리함으로써 비용 및 자원을 절약할 수 있는 특징이 있다. 또한 보안 솔루션 간의 상호 연동을 통해 종합적인 보안 관리 체계를 수립할 수 있다.
  + ```SIM(Security Information Management)``` + ```SEM(Security Event Management)```
+ ESM(Enterprise Security Management)
  + SIEM과 기능은 동일하지만 ```짧은 기간```의 로그 및 보안 이벤트를 관리하는 보안 솔루션
+ 방화벽
  + 기업이나 조직 내부의 네트워크와 인터넷 간에 전송되는 정보를 선별하여 수용/거부/수정하는 기능을 가진 침입 차단 시스템
+ 침입 탐지 시스템 (IDS, Intrusion Detection System)
  + 컴퓨터 시스템의 비정상적인 사용, 오용, 남용 등을 실시간으로 탐지하는 시스템
+ 침입 방지 시스템 (IPS, Intrusion Prevention System)
  + 비정상적인 트래픽을 능동적으로 차단하고 격리하는 등의 방어 조치를 취하는 보안 솔루션
+ 데이터 유출 방지 (DLP, Data Leakage/Loss Prevention)
  + 내부 정보의 외부 유출을 방지하는 보안 솔루션
+ 웹 방화벽 (web Firewall)
  + 일반 방화벽이 탐지하지 못하는 SQL 삽입공격 Cross-Site Scripting(XSS) 등의 웹 기반 공격을 방어할 목적으로 만들어진 웹 서버에 특화된 방화벽
+ VPN(Virtual Private Network, 가상 사설 통신망)
  + 공중 네트워크와 암호화 기술을 이용하여 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션
+ NAC(Network Access Control)
  + 네트워크에 접속하는 내부 PC의 MAC 주소를 IP 관리 시스템에 등록한 후 일관된 보안 관리 기능을 제공하는 보안 솔루션
+ Trustzone
  + 프로세서(processor) 안에 독립적인 보안 구역을 따로 두어 중요한 정보를 보호하는 ARM사에서 개발한 하드웨어 기반의 보안 기술로 프로세서(processor) 안에 독립적인 보안 구역을 별도로 하여, 중요한 정보를 보호하는 하드웨어 기반의 보안 기술이다.

**3A, AAA**  
정보 보호 기술
+ Authentication
  + 시스템을 접근하기 전에 접근 시도하는 사용자의 신원을 검증
+ Authorization
  + 검증된 사용자에게 어떤 수준의 권한과 서비스를 허용
+ Accounting 계정관리 🔴
  + 사용자의 자원(시간, 정보, 위치 등)에 대한 사용 정보를 수집


**DoS 공격**  
시스템을 악의적으로 공격에 해당 시스템의 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격
+ 지역 시스템 공격 / 원격 네트워크 공격

**DDoS 공격**  
DoS 공격의 다른 형태로 여러 대의 공격자를 분산 배치하여 동시에 동작하게 함으로써 특정 사이트를 공격하는 기법  
DoS와 달리 직접 공격을 하지 않고 공격하도록 지시하고 수많은 감염 호스트를 통해 공격을 감행합니다.

**자원고갈 공격**  
<U>SYN 플러팅 / UDP 플러딩 / 스머프 Smurf / PoD (Point of Death)</U>
+ SYN 플러팅
  + 서버의 동시 가용 사용자 수를 SYN 패킷만 보내 점유하여 다른 사용자가 서버를 사용 불가능하게 하는 공격
  + 공격자는 ACK를 발송하지 않고 계속 새로운 연결 요청을 하게 되어 서버는 자원할당을 해지하지 않고 자원만 소비하여 자원이 고갈
+ UDP 플러딩
  + 대량의 UDP 패킷을 만들어 임의의 포트 번호로 전송하여 응답 메시지(ICMP)를 생성하게 하여 지속적으로 자원을 고갈시티는 공격
  + ICMP 패킷은 변조되어 공격자에게 전달되지 않아 대기함
+ 스머프 Smurf
  + 출발지 주소를 공격 대상의 IP로 설정하여 네트워크 전체에게 ICMP Echo 패킷을 직접 브로드캐스팅하여 마비시키는 공격
+ PoD (Point of Death)
  + 큰 사이즈이 패킷을 의도적으로 목표시스템으로 발생시켜 시스템이 서비스할 수 없는 상태로 만드는 공격
  + 비정상 패킷을 잘게 쪼개서 전송

**애플리케이션 공격**  
<U>HTTP GET 플러딩(Flooding) / Slowloris(Slow HTTP Header DoS) / RUDY(Slow HTTP POST DoS)</U>
+ HTTP GET 플러딩(Flooding)
  + Cache Control Attack 공격
  + HTTP 캐시 옵션을 조작하여 캐싱 서버가 아닌 웹서버가 직접 처리하도록 유도, 웹 서버 자원을 소진시키는 서비스 거부 공격
+ Slowloris(Slow HTTP Header DoS)
  + HTTP GET 메서도를 사용하여 헤더의 최종 끝을 알리는 개행 문자열인 ```\r\n\r\n```을 전송시키지 않고 ```\r\n```만 전송하여 대상 웹서버와 연결상태를 장시간 지속시키고 연결 자원을 모두 소진시키는 서비스 거부 공격
+ RUDY(Slow HTTP POST DoS)
  + 요청 헤더의 Content-length를 비정상적으로 크게 설정하여 메시지 바디 부분을 매우 소량으로 보내 계속 연결상태를 유지시키는 공격

**네트워크 서비스 공격**  
<U>스니핑 / 네트워크 스캐너, 스니퍼 / 패스워드 크래킹 / IP 스푸핑 / ARP 스푸핑 / 트로이 목마</U>
+ 스니핑 🔴
  + 공격 대상에게 직접 공격을 하지 않고 데이터만 몰래 들여다보는 수동적 공격 기법
+ 네트워크 스캐너, 스니퍼
  + 네트워크 하드웨어 및 소프트웨어 구성의 취약점 파악을 위해 공격자가 사용하는 도구
+ 패스워드 크래킹
  + 사전 크래킹과 무차별 크래킹 방법을 사용해 네트워크 패스워드를 탐색
  + 대표적인 공격 도구로 John the Ripper가 있음
+ IP 스푸핑
  + 서버에 대한 인증되지 않은 액세스 권한을 입수하는데 사용하는 방법
  + 침입자가 패킷 헤더 수정을 통해 인증된 호스트의 IP 어드레스를 위조
+ ARP 스푸핑 🔴
  + ARP 스푸핑은 공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply를 만들어 희생자에게 지속적으로 전송하여 희생자의 ARP Cache Table에 특정 호스트의 MAC 정보를 공격자의 MAC 정보로 변경, 희생자로부터 특정 호스트로 나가는 패킷을 공격자가 스니핑하는 공격기법
+ ICMP Redirect 공격
  + ICMP 리다이렉트는 3계층에서 스니핑 시스템을 네트워크에 존재하는 또 다른 라우터라고 알림으로써 패킷의 흐름을 바꾸는 공격 기법
  + ICMP Redirect 메시지를 공격자가 원하는 형태로 만들어서 특정 목적지로 가는 패킷을 공격자가 스니핑하는 공격 기법
+ 트로이 목마 🔴
  + 악성 루틴이 숨어 있는 프로그램으로서 겉보기에는 정상적인 프로그램처럼 보이지만 실행하면 악성 코드를 실행
  + **정상적인 프로그램으로 가장**해 사용자가 직접 컴퓨터에 설치하도록 위장하며, 백도어를 만들어 공격자가 침입할 수 있도록 만들거나 시스템을 파괴
  + 정상적인 프로그램으로 위장하여 시작부터 끝까지 램에 상주하며, 시스템 내부 정보를 공격자의 컴퓨터로 빼돌리는 프로그램
  + 좀비 PC처럼 내부정보 유출뿐만 아니라 컨트롤까지 가능한 종류, 단순히 내부 데이터만 유출할 수 있는 타입
  + 감염된 후에 스스로를 복제하는 능력은 없음
+ 웜 🔴
  + 감염된 컴퓨터 시스템에서 스스로 복제해 다른 컴퓨터로 복사본을 확산시킬 수 있는 악성 프로그램
  + 독자적으로 실행되며 다른 실행 프로그램이 필요하지 않으며, 파일 전송 기능을 착취하도록 설계
  + 자가 복제 및 ```네트워크```를 통한 전파도 가능
+ 바이러스 🔴
  + ```대상(정상파일)```을 감염시키는 형태로 실행되며, 감염시킬 대상이 존재하지 않을 때에는 실행되지 않으며 다른 정상파일로의 자기 복제 기능
  + 컴퓨터 시스템에 침입해 프로그램에 기생하며 시스템을 변경하거나 사용할 수 없도록 만드는 악성코드
  + 네트워크를 통해 전파되지 않으며 방식 및 위치에 따라 여러 형태로 나뉨

**취약점 공격**  
<U>랜드 어택 / 봉크, 보잉크 / 티어 드롭</U>
+ 랜드 어택 🔴
  + 출발지 IP와 목적지 IP를 같은 패킷 주소로 만들어 보냄
  + 공격자가 패킷의 출발지 주소나 포트를 임의로 변경해 출발지와 목적지 주소를 동일하게 함으로써 공격 대상 컴퓨터의 실행속도를 느리게 하거나 동작을 마비시켜 서비스 거부 상태에 빠지도록 하는 공격 방법
+ 봉크, 보잉크
  + 프로토콜의 오류 제어를 이용한 공격기법으로 시스템의 패킷 재전송과 재조립이 과부하를 유발
  + ```봉크```: 같은 시퀀스 번호를 계속 보냄
  + ```보잉크```: 일정한 간격으로 시퀀스 번호에 빈 공간 생성
+ 티어 드롭
  + IP 패킷의 재조합 과정에서 잘못된 Fragment Offset 정보로 인해 수신시스템 문제를 발생하도록 하는 DoS 공격

**암호 알고리즘**
+ 대칭키 암호방식
  + 암복호화에 같은 암호키를 쓰는 알고리즘
  + 블록 암호방식: AES, DES, ARIA, SEED, HIGHT, IDEA
  + 스트림 암호방식: RC4
+ 비대칭키 암호방식
  + 공캐키를 암호화하고 공개키에 해당하는 개인키를 이용해 복호화하는 암호방식
  + 디피-헬만, RSA
+ 해시방식
  + 단방향 알고리즘으로서 임의의 데이터를 고정된 길의의 데이터로 매핑하는 함수
  + SHA, MD5

DES(Data Encryption Standard) 🔴
+ IBM에서 개발한 56bit의 키를 이용, 64bit의 암호문 블록으로 만드는 블록 암호 방식의 미국표준 암호화 알고리즘
+ 블록 암호의 일종으로, 미국 NBS (National Bureau of Standards, 현재 NIST)에서 국가 표준으로 정한 암호이다.
+ 64비트 평문을 64비트 암호문으로 암호화하는 대칭키 암호 알고리즘이다.
+ 키는 7비트마다 오류검출을 위한 정보가 1비트씩 들어가기 때문에 실질적으로는 ```56비트```이다.

AES(Advanced Encryption Standard) 🔴
+ 고급 암호화 표준
+ DES를 대체하며, ```128비트``` 블록 크기와 128,192,256비트 키 크기의 대칭 키 암호화 방식

SEED
+ 안정성, 신뢰성이 우수한 128bit 단위의 대칭 키 암호화 알고리즘

IDEA 🔴
+ Xuejia Lai와 James Messey가 만든 알고리즘으로 PES(Proposed Encryption Standard)에서 IPES(Improved PES)로 변경되었다가, 1991년에 제작된 블록 암호 알고리즘으로 현재 국제 데이터 암호화 알고리즘으로 사용되고 있다.
+ 64비트 블록을 128비트의 key를 이용하여 8개의 라운드로 구성되어 있다.
+ DES를 대체하기 위해서 스위스에서 개발한 알고리즘

SKIPJACK, 스킵잭 🔴
+ 미국의 NSA에서 개발한 Clipper 칩에 내장되는 블록 알고리즘이다. 전화기와 같은 음성을 암호화 하는데 주로 사용되며 64비트 입출력에 80비트의 키 총 32라운드를 가진다.

RSA(Rivest Shamir Adleman)
+ 비대칭 키 암호 방식 중에서 가장 널리 쓰이는 방식으로 소인수 분해의 어려움을 이용한 방식

SHA(Secure Hash Algorithm)
+ 미국 국가안보국이 설계한 미국 국가 표준 지정된 해시 암호화 알고리즘, SHA-1, SHA-2

MD5(Message-Digest Algorithm 5) 🔴
+ MD4를 대체하기 위해 사용하는 128bit 해시 암호화 알고리즘

HAS-160
+ 국내 표준 서명 알고리즘을 위해 개발된 알고리즘으로 MD5와 SHA-1의 장점을 취하여 개발된 해시 알고리즘

<br>

### 9-2. 소프트웨어 개발 보안 구현
**입력 데이터 검증 및 표현 공격**
+ SQL 삽입 🔴
  + 응용 프로그램의 보안 취약점을 이용해서 악의적인 SQL 구문을 삽입, 실행시켜서 데이터베이스의 접근을 통해 정보를 탈취하거나 조작 등의 행위를 하는 공격 기법
+ 크로스 사이트 스크립트(XSS)
  + 검증되지 않은 외부 입력값에 의해 브라우저에서 악의적인 코드가 실행
+ 사이트 간 요청 위조(CSRF)
  + 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹 사이트에 요청하게 하는 공격
+ 경로 조작 및 자원 삽입
  + 외부 입력값이 사전 검증 없거나 잘못 처리될 경우
+ 운영체제 명령어 삽입
  + 운영체제 명령어 파라미터 입력값이 적절한 사전 검증을 거치지 않고 사용될 때 공격자가 운영체제 명령어를 조작

<br>

****
**용어정리**

| 용어                                 | 설명                                                                                       |
|------------------------------------|------------------------------------------------------------------------------------------|
| 디피-헬만                              | 암호 키를 교환하는 방법으로서 두 사람이 암호화되지 않은 통신망을 통해 공통의 비밀 키를 공유할 수 있도록 하는 방식                        |
| SSL(Secure Socket Layer)           | 응용계층과 TCP/IP 계층 사이에서 웹 데이터 암호화 및 전송 시 기밀성을 보장하는 공개키 기반의 보안 프로토콜                          |
| 솔트                                 | 일방향 해시 함수에서 다이제스트를 생성할 때 추가되는 바이트 단위의 임의의 문자열                                            |
| 세션 하이재킹 🔴                         | TCP 신뢰성 기반의 연결을 이용한 공격 방법으로 통신 내용을 엿보거나 세션을 가로채어 정상적인 인증 과정을 무시하고, 불법으로 시스템에 접근할 수 있는 공격 |
| Mutex 상호배제                         | 임계영역을 가진 스레드들의 실행 시간이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술                                       |
| LEAD                               | 파티션별 윈도에서 이후 로우의 값을 반환하는 함수                                                              |
| 세션                                 | 클라이언트와 서버의 논리적인 연결                                                                       |
| 싱글톤 패턴                             | 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴                          |
| 모델 체킹                              | 정형언어로 명세된 모델을 검증하고자 하는 특성을 만족하는지 입증하는 기법                                                 |

** 세션은 웹 개발에서 클라이언트와 서버 간의 상태를 유지하기 위해 사용되는 개념이며, IP는 네트워크 통신에서 기기를 인터넷에서 식별하기 위해 사용되는 주소 체계입니다.

<br><br>

## 10장. 프로그래밍 언어 활용
### 10-1. 기본 문법 활용하기
**변수 활용**
+ 바인딩
  + 정적 바인딩 - 프로그램 실행 시간 전에 속성을 연결하는 방식
  + 동적 바인딩 - 프로그램 실행 시간에 속성을 연결하는 방식
+ 자료구조
  + 컴퓨터에 데이터를 삽입, 삭제, 수정하게 해주는 논리적인 공간 구조
  + 단순구조 / 선형구조 / 비선형구조 / 파일구조
  + ```float```은 4바이트 소수점 6자리까지 표현, ```double```은 8바이트 소수점 15자리까지 표현
+ 알고리즘
  + 어떤 문제에 대한 답을 찾는 해법
+ 데이터 타입
  + 실수치, 정수 자료형과 같은 여러 종류의 데이터를 식별하는 형태
  + 메모리 공간을 효율적으로 사용하고 2진수 데이터를 다양한 형태로 사용하기 위해 존재
+ 변수
  + 저장하고자 하는 어떤 값이 있을 때, 그 값을 주기억 장치에 기억하기 위한 공간을 의미
  + 어떤 값을 주기억 장치에 기억하기 위해서 사용하는 공간이고, 데이터 타입은 변수가 가질 수 있는 속성값의 길이 및 성질입니다.

**연산자**  
프로그램 실행을 위해 연산을 표현하는 기호로 산술연산자, 시프트 연산자, 관계연산자, 논리연산자, 비트연산자, 대입연산자, 증감연산자
+ ```&``` 두 값을 비트로 연산하여 모두 참이면 참을 반환하고, 그렇지 않으면 거짓을 반환하는 연산자
+ ```|``` 두 값을 비트로 연산하여 하나가 참이면 참을 반환하고, 그렇지 않으면 거짓을 반환하는 연산자
+ ```^``` 두 값을 비트로 연산하여 서로 다르면 참을 반환하고, 그렇지 않으면 거짓을 반환하는 연산자

**사용자 정의 자료형**  
사용자가 상황에 맞게 기존 자료형을 조합해서 만드는 자료형
+ 열거체(Enumeration)
  + 서로 연관된 정수형 상수들의 집합
+ 구조체(Structure)
  + 사용자가 기본 타입을 가지고 새롭게 정의할 수 있는 사용자 자료형
  ```
  struct 구조체명{
    char gender;
    int age;
    int school_name; 
  }
  ```
+ 공용체(Union)
  + 모든 멤버 변수가 하나의 메모리 공간을 공유하는 사용자 정의 자료형
  + 모든 변수가 다른 메모리에 할당되어 있는 구조체와 달리, 공용체는 모든 변수가 같은 메모리에 할당되어 있음
  ```
  union 구조체명{
    char gender;
    int age;
    int school_name; 
  }
  ```

**추상화와 상속**
+ **추상화**는 세부 사항은 배제하고 중요한 부분을 중심으로 간략화하는 기법
+ **상속**은 상위 수준 그룹의 모든 특성을 하위 수준 그룹이 이어받아 재사용 또는 확장하는 기법
+ **구체화**란 하위 수준 그룹이 상위 수준 그룹의 추상적인 부분을 구체화하는 방법

<br>

### 10-2. 언어 특성 활용하기
**구현 기법에 따른 분류**
+ 컴파일 방식의 언어
  + 고급 언어를 기계어로 번역하는 방식의 언어
  + FORTRAN, PASCAL, C, C++
+ 인터프리터 방식의 언어
  + 고급 언어 명령문을 하나씩 번역하고 실행하는 방식의 언어
  + BASIC, 프롤로그, LISP
+ 혼합형 방식의 언어
  + 고급 언어를 컴파일하여 중간 언어로 변환한 후, 인터프린터에 의해 번역을 실행하는 방식의 언어
  + 자바

**프로그래밍 언어별 특성**
+ 절차적 프로그래밍 언어
  + ALGOL, C, BASIC, FORTRAN
+ 객체지향 프로그래밍 언어
  + 객체와 객체 간 통신을 통해 프로그램을 구현
  + 객체, 클래스, 메시지
  + 객체의 구성요소 - **개체, 속성, 메서드**
  + C++, C, JAVA, Delphi
+ 스크립트 언어
  + PHP, Perl, Python, JS
+ 선언형 언어
  + 하스켈, 리스프, 프롤로그, SQL

**라이브러리**  
효율적인 프로그램 개발을 위해 필요한 프로그램을 모아 놓은 집합체, 모듈과 패키지

<br>

### 10-3. 프로그래밍 예제 및 알고리즘
**C 언어**
```
#includ<stdio.h>

void main(){
  char a = 'B';
  printf("a\n");  // a  
  // printf만으로는 띄어쓰기 안됨
}
```
```
🔴
void main(){
  char *p="KOREA";
  printf("%s\n", p);        // KOREA
  printf("%s\n", p+3);      // EA
  printf("%c\n", *p);       // K
  printf("%c\n", *(p+3));   // E
  printf("%c\n", *p+2);     // M
}

// p라는 포인터는 KOREA라는 저장공간이 할당된 곳을 가리키는데, 문자 마직막에는 NULL이 자동으로 생성
// %s는 문자열을 출력하고, %c는 문자를 출력
// p를 출력하면 p 주소부터 NULL까지의 값을 읽어오므로, 'KOREA'가 출력
// p+3을 출력하면 K에서 3번째인 E부터 NULL까지 읽으므로 'EA'가 출력
 
```

**C++ 언어**  
```using namespace std;```를 사용했으므로 ```std::cout``` 작성할 필요가 없습니다. (네임스페이스에 포함됨을 명시)
```
#includ<iostream>
using namespace std;
void main(){
  cout << "Hello world";
}
cout << endl;
```
```
cout << hex << a << endl; // a 변수값을 16진수로 출력
cout << (a<<2) << endl;   // a를 왼쪽으로 2비트 이동한 결과를 10진수로 출력
```

**파이썬**  
파이썬 함수 🔴
+ extend: 요소를 확장해준다는 의미를 가지고 있으며, 모든 항목을 하나의 요소로 추가
+ pop: 리스트 내부 요소를 꺼내주는 함수로써, 그 요소는 리스트 안에서 삭제하고 그 값을 반환
+ reverse: 리스트 내부의 요소의 순서는 뒤집는 역할

```
print(oct(a)); // a 변수값을 16진수로 출력
print(7/3);    // 2.33333 파이썬에서만 '/' 기호값으로 소수점까지 다 출력
               // '%' 연산은 다른 언어들과 동일
```

```
for i in range(1,10): // 1~9까지 연산
  print(ai)               
```

```
class A:
  def fnA():
    print('A클래스')
    
class B(A):       // A 클래스 상속
  def fnB():
    print('B클래스')
```

```
a.update({'홍콩', '한국', '태국'})  // 기존 a에서 중복 제외 추가
print(a)  

// {'홍콩', '한국', '태국'} 이렇게 {}까지 출력 🔴
```

```
lol=[[1,2,3],[4,5],[6,7,8,9]]
print(lol[0])
print(lol[2][1])
for sumb in lol:
  for item in sub:
    print(item, end='')
  print() 
  
[1,2,3] 🔴
7 
123
45
6789  
```

```python
a = 100
result = 0
for i in range(1,3);  // i = 1 or 2
   result = a >> i
   result = result + 1
print(result)

// 26
```
+ ```range(1,3)```에서 끝 값을 제외하고 1, 2만 대입
+ list의 경우에도 ```[0:3]```인 경우에는 끝 값을 제외하고 1, 2만 대입
+ i가 1일 때, ```1100100``` 값을 ```>>``` 처리하면 ```110010```이 되고, 이 값이 result가 된다.
+ i가 2일 때도 동일하게 진행! 여기서 주의할 점은 a 값은 계속 100으로 변화가 없다는 것이다. 🔴

**자바**
```java
public class Conv{ 
  public Conv(int a) {
    this.a = a;
  } 
  int func() {
    int b =1; 
    for (int i=1; i<a; i++){ 
      b = a * i + b; 
    }
    return a + b;
  }
}
 
public static void main(String[] args){
  Conv obj = new Conv(3);
  obj.a=5; 
  int b = obj.func();
  system.out.print(obj.a + b);  // 61
}
```
+ b는 a가 1~4일 때의 func()의 return 값을 구하면 되는 문제입니다.
+ func()의 연산을 순서대로 보면, 🔴
  + b = 5*1+1 = 6
  + b = 5*2+6 = 16
  + b = 5*3+16 = 31
  + b = 5*4+31 = 51
  + return 값은 5+51=56 이 됩니다.
+ 따라서 obj.a+b = 5+56 = 61

```java
public class testco {
   public static void main(String[] args) {
      int a = 3, b = 4, c = 3, d = 5;
      if((a == 2 | a == c) & !(c > d) & (1 == b ^ c != d)) {
         a = b + c;
          if(7 == b ^ c != a) {
             System.out.println(a);     // 7
          } else {
             System.out.println(b);
          }
      } else {
          a = c + d;
          if(7 == c ^ d != a) {
             System.out.println(a);
          } else {
             System.out.println(d);
          }
      }
   }
}

// 7
```
+ ```^``` XOR연산자로써 두 값이 같으면 False, 아니면 True를 반환한다
+ ```1 == b ^ c != d``` 부분은 ```1 == b```와 ```c != d```로 나누어서 생각한다. ```1 == b```는 거짓이지만 ```c != d```는 참이기 때문에 결과적으로 ```^``` 연산으로 true가 된다. 🔴

```java
public class ClassA {
   public static void main(String args[]) {
      System.out.println(check(1));
   }
   static String check(int num){
   }
}

// static
```
+ 클래스를 생성하지 않고 사용할 수 있는 메소드를 선언할 때 사용하는 static 🔴

```java
class Parent{
  public int compute(int num){
    if(num<=1) return num;
    return compute(num-1)+compute(num-2);
  }
}

class Child extends Parent{
  public int compute(int num){
    if(num<=1) return num;
    return compute(num-1)+compute(num-3);
  }
}

class Main{
  public staic void main(String[] args){
    Parent obj = new Child();
    System.out.print(obj.compute(4));
  }
}
```
+ 오버라이딩으로 Child의 compute 메서드를 실행 🔴
+ compute(1) + compute(-1) + compute(0) + compute(1) = 1

<br>

**논리연산자**  
일반적으로 프로그래밍 언어에서 0이면 ```False```를 나타내고 0 이외의 값은 ```True```로 판단

**접근제어 지시자**
+ **private** 인스턴스 변수와 메서드는 선언된 클래스 내부에서 접근 가능
+ **protected** 상속받은 클래스에 접근을 허용
+ **public** 어디서든 접근 가능한 인스턴스 변수 및 메서드
+ 파이썬에서 ```_```(private), ```__```(protected)

**오버로딩**  
동일 이름의 메서드를 여러 개 정의할 수 있는 특성
+ 메서드 이름이 같고, 매개변수 수나 타입이 다른 특성을 가짐
+ 반환형은 같거나 달라도 됨
+ 파이썬은 메서드 오버로딩을 지원하지 않음

**오버라이딩**  
하위 클래스에서 상위 클래스를 재정의할 수 있는 특성
+ 메서드는 상위클래스와 동일(매개변수, 메서드명, 반환타입 모두)

**인터페이스**  
자바의 다형성을 극대화하여 개발코드 수정을 줄이고 프로그램 유지보수성을 높이기 위한 문법

**추상클래스**  
미구현 추상 메서드를 한 개 이상 가지며, 자식 클래스에서 해당 추상 메서드를 반드시 구현하도록 강제하는 문법  
상속받은 클래스는 추상 메서드를 구현하지 않아도, import할 때까지 에러가 발생하지 않으나 객체를 생성할 때 에러가 발생

<br>

****
**용어정리**

| 용어    | 설명                                        |
|-------|-------------------------------------------|
| 컴파일러  | FORTRAN, C와 같은 고급 언어를 기계어로 번역하는 프로그램이자 도구 |
| 인터프리터 | 프로그램 문장을 하나씩 번역하고 실행할 수 있도록 하는 프로그램     |

<br><br>

## 11장. 응용 SW 기초 기술 활용
### 11-1. 운영체제의 특징
**유닉스 운영체제** 🔴
> 데니스 리치와 켄톰슨 등이 함께 벨 연구소를 통해 만든 운영체제이며, 90% 이상 C언어로 구현되어 있고, 시스템 프로그램이 모듈화되어 있어 다른 하드웨어 기종으로 쉽게 이식 가능하며 계층적 트리 구조를 가짐으로써 통합적인 파일 관리가 용이한 운영체제

교육 및 연구 기관에서 사용되는 범용 다중 사용자 방식의 사분할 운영체제  
대화식 운영체제, 다중 작업 기능 제공, 다중 사용자 기능 제공, 이식성 제공, 계층적 트리 구조 파일 시스템 제공
+ 리눅스 운영체제
+ 맥 운영체제
+ 안드로이드 운영체제 🔴
  + 구글에서 개발한 운영체제로 리눅스 위에서 구동하며 휴대폰 전화를 비롯한 휴대용 장치를 위한 운영 체제와 미들웨어, 사용자 인터페이스 그리고 표준 운영 프로그램 등을 포함하고 있는 소프트웨어 스택이자 리눅스 모바일 운영체제

**운영체제 핵심 기능**
+ 메모리 관리
  + 프로그래므이 실행이 종료될 때까지 메모리를 기용한 상태로 유지 및 관리하는 기능
  + 메모리에 있는 프로그램은 CPU로 이동하여 처리
  + 반입기법, 배치기법, 할당기법, 교체기법
+ 프로세스 관리
  + CPU와 데이터를 송수신하는 상황에서 현재 메모리 사용부분, 메모리 입출력 순서, 메모리 공간 확보 등 프로세스에 대한 종합적인 관리 기법

![process-status.png](/assets/post_images/cs/process-status.png)

**프로세스 상태**
+ 생성상태, 준비상태, 실행상태, 대기상태(우선순위가 존재하지 않음), 완료상태 🔴

**프로세스 상태전이**
+ 디스패치(Dispatch)
  + 준비 상태에 있는 여러 프로세스 중 실행될 프로세스를 선정하여 CPU 할당 - 문맥교환 발생
+ 타이머 런 아웃(Timer run out)
  + 디스패치와 반대로 CPU를 할당받은 프로세스는 지정된 시간이 초과되면 스케줄러에 의해 PCB 저장, CPU 반납 후 다시 준비 상태로 전이됨
+ 블록(Block/Sleep)
  + 실행상태에서 프로세스가 지정된 할당시간을 초과하기 전에 입출력이나 기타 사건이 발생하면 CPU를 스스로 반납하고 입출력이 완료될 때까지 대기 상태로 전이됨
+ 웨이크업(Wake-up)
  + 어느 순간에 입출력이 종료되면 대기 상태의 프로세스에게 입출력 종료 사실을 wait & signal 등에 의해 알려주고, 준비 상태로 전이됨
+ Swap-in
  + 프로세스에게 다시 기억장치가 할당될 경우
  + 지연준비/지연대기 상태에서 준비 또는 대기 상태로
+ Swap-out
  + 프로세스가 기억장치를 잃은 경우

**프로세스 스케줄링**  
CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 기법
+ 선점형 스케줄링, 비선점형 스케줄링

**선점형 스케줄링**  
하나의 프로세스가 CPU를 차지하고 있을 때 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식  
<U>라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐</U>
+ 라운드 로빈 RR 🔴
  + 프로세스는 같은 크기의 CPU 시간을 할당, 프로세스가 할당된 시간 내 처리 완료를 못하면 준비 큐 리스트의 가장 뒤로 보내지고, CPU가 대기 중인 다음 프로세스로 넘어감
+ SRT(Shortest Remaining Time First) 🔴
  + 가장 짧은 시간이 소요되는 프로세스를 먼저 수행하고, 남은 처리 시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라도 프로세스가 선점됨
+ 다단계 큐
  + 작업들을 여러 종류 그룹으로 분할, 여러 개 큐를 이용하여 상위단계 작업에 의한 하위단계 작업이 선점 당함
+ 다단계 피드백 큐
  + 입출력 위주와 CPU 위주인 프로세스의 특성에 따라 큐마다 서로 다른 CPU 시간 할당량을 부여

**비선점형 스케줄링**  
한 프로세스가 CPU를 할당받으면 작업 종료 후 CPU 반환시까지 다른 프로세스는 CPU 점유가 불가능한 스케줄링 방식  
<U>우선순위, 기한부, FCFS, HRN, SJF</U>
+ 우선순위
  + 프로세스별 우선순위가 주어지고 우선순위에 따라 CPU를 할당, 동일 순위는 FCFS
+ 기한부
  + 작업들이 명시된 시간이나 기한 내 완료되도록 계획
+ FCFS(First Come First Service) = FIFO
  + 프로세스가 대기 큐에 도착한 순서에 따라 CPU를 할당함
+ SJF(Shortest Job First) 🔴
  + 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료시까지 자원 점유
  + 기아현상 발생
+ HRN(Highest Response Radio Next)
  + 대기 중인 프로세스 중 현재 응답률이 가장 높은 것을 선택
  + SJF의 약점인 기아현상을 보완한 기법으로 긴 작업시간과 짧은 작업시간 간의 불평등 완화
  + ```(대기시간 + 서비스시간)/서비스시간``` 🔴

**가상화**  
물리적인 리소스들을 사용자에게 하나로 보이게 하거나, 하나의 물리적인 리소스를 여러 개로 보이게 하는 기술  
가상화를 이용하면 서버 용량의 20% 사용에 불과하는 부분을 60~70% 이상으로 올릴 수 있습니다.

**클라우드 컴퓨팅**  
인터넷을 통해 가상화된 컴퓨터 시스템 리소스를 제공하고, 정보를 자신의 컴퓨터가 아닌 클라우드에 연결된 다른 컴퓨터로 처리하는 기술  
클라우딩 컴퓨팅 유형
+ 인프라형 서비스 (IaaS, Infrastructure as a Service)
  + 서버, 스토리지 같은 시스템 자원을 클라우드로 제공하는 서비스
+ 플랫폼형 서비스 (PaaS, Platform as a Service)
  + 인프라를 생성, 관리하는 복잡함 없이 애플리케이션을 개발, 실행 관리할 수 있게 하는 플랫폼을 제공하는 서비스
+ 소프트웨어형 서비스 (SaaS, Software as a Service)
  + 소프트웨어 및 관련 데이터는 중앙에 호스팅되고 사용자는 웹 브라우저 등 클라이언트를 통해 접속하여 소프트웨어를 서비스 형태로 이용하는 서비스

<br>

### 11-2. 데이터베이스 기초 활용하기
**데이터베이스**  
파일 시스템, 계층형 데이터베이스, 망형 데이터베이스, 관계형 데이터베이스

**DBMS(Database Management System)**  
데이터 관리의 복잡성을 해결하는 동시에 데이터 추가, 변경, 검색, 삭제 및 백업, 복구, 보안 등의 기능을 지원하는 소프트웨어
+ 키-값 DBMS
+ 컬럼 기반 데이터 저장 DBMS
+ 문서저장 DBMS
+ 그래프 DBMS

데이터 무결성 / 일관성 / 회복성 / 보안성 / 효율성

**관계형 데이터베이스 활용**  
ERD(E-R Diagram)   
업무 분석결과로 도출된 실체(엔티티)와 엔티티 간의 관계를 도식화한 다이어그램, 엔티티 / 속성 / 관계

**트랜잭션**  
인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야 하는 특성이자, 데이터베이스 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위

트랜잭션의 특성 ```ACID```
+ 원자성(Atomicity) 🔴
  + 분해가 불가능한 작업의 최소단위
  + 연산 전체가 성공 또는 실패
  + 구성하는 연산 자체가 모두 정상적으로 실행되거나 모두 취소되어야 하는 특성
+ 일관성(Consistency)
  + 트랜잭션이 실행 성공 후 향상 일괄된 데이터베이스 상태를 보존해야 하는 특성
+ 격리성(Isolation)
  + 트랜잭션 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근 불가한 특성
+ 영속성(지속성)(Durability) 🔴
  + 성공이 완료된 트랜잭션의 결과는 영속적으로 데이터베이스에 저장하는 특성

트랜잭션 제어어(TCL, Transaction Control Language)
+ COMMIT
+ ROLLBACK 🔴
  + 트랜잭션 처리중 오류가 발생했을 때, 오류 이전의 특정 시점으로 되돌려주는 명령어
+ CHECKPOINT

**회복기법의 종류**
+ 로그 기반 회복 기법
  + 지연 갱신 회복 기법 (Deferred Update)
    + 트랜잭션이 완료되기 전까지 데이터베이스에 기록하지 않는 기법
  + 즉각 갱신 회복 기법 (Immediate Update) 🔴
    + 트랜잭션 수행 중 갱신 결과를 바로 DB에 반영하는 기법
    + 데이터베이스의 회복 기법 중 Rollback 시 Redo, Undo 모두 실행되는 트랜잭션 처리법으로 트랜잭션 수행 중 갱신 결과를 바로 DB에 반영하는 기법
      + REDO 🔴: 오류가 발생하기 전까지의 사항을 로그로 기록해 두고 이전 상태로 되돌아간 후 실패가 발생하기 전까지의 과정을 재실행
      + UNDO 🔴: 로그를 이용하여 오류와 관련된 내용을 취소하여 복구
+ 체크 포인트 회복 기법
  + 장애 발생시 검사점 이후에 처리된 트랜잭션에 대해서만 장애 발생 이전의 상태로 복원시키는 회복기법
+ 그림자 페이징 회복 기법
  + 데이터베이스 트랜잭션 수행 시 복제본을 생성하여 데이터베이스 장애 시 이를 이용해 복구하는 기법

**데이터베이스 고립화 수준**
+ Read Uncommitted
  + 한 트랜잭션에서 연산 중인 데이터를 다른 트랜잭션이 읽는 것을 허용, 연산 중인 데이터에 대한 연산은 불허
+ Read Committed
  + 한 트랜잭션에서 연산을 수행할 때, 연산이 완료될 때까지 연산대상 데이터에 대한 읽기를 제한, 연산이 완료되어 커밋된 데이터는 다른 트랜잭션이 읽는 것을 허용
+ Repeatable Read
  + 선행 트랜잭션이 특성 데이터를 읽을 때, 트랜잭션 종료 시까지 해당 데이터에 대한 갱신/삭제를 제한
+ Serializable Read
  + 선행 트랜잭션이 특정 데이터 영역을 순차적으로 읽을 때, 해당 데이터 영역 전체에 대한 접근을 제한

**빅데이터**  
시스템, 서비스 조직 등에서 주어진 비용, 시간 내에 처리 가능한 데이터 범위를 넘어서는 페타바이트(PB) 크기의 비정형 데이터

**NoSQL(Not Only SQL)**  
JOIN을 사용할 수 없고 수평적 확장이 가능한 DBMS로 전통적인 RDBMS와 다른 DBMS를 지칭하기 위한 용어

**데이터 마이닝** 🔴    
대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 기술

```sql
SELECT COUNT(COL2)
FROM TBL
WHERE COL1 IN (2,3) OR COL2 IN (3,5);
```
| COL1 | COL2 | COL3 |
|:----:|:----:|:----:|
|  2   | NULL |  1   |
|  3   |  7   | NULL |
|  4   |  5   |  5   |
|  5   |  3   | NULL |
| NULL |  3   |  9   |

+ count()에서 NULL 값인 것은 제외하고 카운팅한다.

<br>

### 11-3. 네트워크 기초 활용하기
**네트워크**  
원하는 정보를 원하는 수신자 또는 기기에 정확하게 전송하기 위한 기반 인프라
+ WAN, 광대역 네트워크: 라우팅 알고리즘이 필요
+ LAN, 근거리 네트워크: 한 건물 또는 작은 지역을 커버하는 네트워크

VPN (Virtual Private Network)
+ 인터넷을 통해 디바이스 간에 사설 네트워크 연결을 생성하며, 퍼블릭 네트워크를 통해 데이터를 안전하게 익명으로 전송하는 데 사용된다.
+ 또한 사용자 IP 주소를 마스킹하고 데이터를 암호화하여 수신 권한이 없는 사람이 읽을 수 없도록 한다.

**[OSI 7계층](/cs/2023/04/13/CS_certificate.html#1-1-현행-시스템-분석)**  
제어 정보들은 모두 운영체제가 제공하는 프로토콜에 의해 송신 측에서는 계층을 지날 때마다 덧붙여서 추가되고, 수신 측에서는 계층을 지날 때마다 제거

1계층
+ 허브
  + 여러 대의 컴퓨터를 연결하여 네트워크로 보내거나, 하나의 네트워크로 수신된 정보를 여러 대의 컴퓨터로 송신하기 위한 장비
+ 리피터
  + 디지털 신호를 증폭시켜주는 역할을 하여 신호가 약해지지 않고 컴퓨터로 수신되도록 하는 장비

2계층
+ 브리지
  + 두 개의 근거리통신망(LAN)을 서로 연결해 주는 통신망 연결 장치
+ L2 스위치
  + 느린 전송속도의 브리지, 허브의 단점을 개선하기 위해 출발지에서 들어온 프레임을 목적지 MAC 주소 기반으로 빠르게 전송시키는 데이터 링크 계층의 통신 장치

3계층
+ 라우터
  + LAN과 LAN을 연결하거나 LAN과 WAN을 연결하기 위한 인터넷 네트워킹 장비
  + 패킷의 위치를 추출하여 그 위치에 대한 최적의 경로를 지정하며, 이 경로를 따라 데이터 패킷을 다음 장치로 전송시키는 장비
+ 게이트웨이
  + 프로토콜을 서로 다른 통신망에 접속할 수 있게 해주는 장치
  + LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할
+ L3 스위치
  + 3계층에서 네트워크 단위들을 연결하는 통신장비
  + IP 레이어에서의 스위칭을 수행하여 외부로 전송

4계층
+ L4 스위치
  + 4계층에서 네트워크 단위들을 연결하는 통신장비
  + TCP/UDP 등 스위칭 수행
  + FTP, HTTP 등을 구분하여 스위칭하는 로드 밸런싱 기능

**애드 혹 네트워크** 🔴
+ 노드들에 의해 자율적으로 구성되는 기반 구조가 없는 네트워크로 구성 및 유지를 위해 기지국이나 액세스 포인트와 같은 기반 장치를 필요로 하지 않는 네트워크
+ 노드들은 무선 인터페이스를 사용하여 서로 통신하고 멀티 홉 라우팅 기능에 의해 무선 인터페이스가 가지는 통신 거리상의 제약을 극복하며, 노드들의 이동이 자유롭기 때문에 네트워크 토폴로지가 동적으로 변화되는 특징이 있음
+ 응용 분야로는 긴급 구조, 긴급회의, 전쟁터에서의 군사 네트워크 등이 있음

**프로토콜** 🔴  
서로 다른 시스템이나 기기들 간의 데이터 교환을 원활히 하기 위한 표준화된 통신규약  
심리학자 톰 마릴은 컴퓨터가 메시지를 전달하고 메시지가 제대로 도착했는지 확인하며, 도착하지 않았을 경우 메시지를 재전송하는 일련의 방법을 '기술적 은어'로 프로토콜이라 부름

프로토콜의 기본요소 ```구의타``` 🔴
+ 구문: 시스템 간의 정보 전송을 위한 데이터 형식, 코딩, 신호 레벨 등의 규정
+ 의미: 시스템 간의 정보 전송을 위한 제어 정보로 조정과 에러 처리를 위한 규정
+ 타이밍: 시스템 간의 정보 전송을 위한 속도 조절과 순서 관리 규정

네트워크 프로토콜  
컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고받는 양식과 규칙의 체계
+ IP(Internet Protocol)
  + 송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용하는 통신 프로토콜
+ ARP(Address Resolution Protocol)
  + IP 네트워크 상에서 IP주소를 MAC 주소(물리주소)로 변환하는 프로토콜
+ RARP(Reverse Address Resolution Protocol) 🔴
  + IP 호스트가 자신의 물리 네트워크 주소는 알지만 IP주소를 모르는 경우, 서버로부터 IP 주소를 요청하기 위해 사용하는 프로토콜
+ ICMP(Internet Control Message Protocol)
  + IP 패킷을 처리할 때 발생하는 문제를 알려주는 프로토콜 메시지 형식은 8bit 헤더와 가변 길이의 데이터 영역으로 분리
+ IGMP(Internet Group Management Protocol)
  + 인터넷 그룹 관리 프로토콜은 호스트 컴퓨터와 인접 라우터가 멀캐스트 그룹 멤버십을 구성하는데 사용하는 통신 프로토콜
+ 라우팅 프로토콜(Routing Protocol)
  + 데이터 전송을 위해 목적지까지 갈 수 있는 여러 경로 중 최적의 경로를 설정해주는 라우터 간의 상호 통신 프로토콜

TCP(Transmission Control Protocol)  
전송 제어 프로토콜은 인터넷 프로토콜 스위트의 핵심 프로토콜 중 하나  
전송 계층에 위치하면서 근거리 통신망이나 인트라넷, 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟을 안정적으로 순서대로 에러 없이 교환할 수 있게 해주는 프로토콜

UDP(User Datagram Protocol)  
비연결성이고 신뢰성이 없으며, 순서화되지 않은 데이터그램 서비스를 제공하는 전송 계층의 통신 프로토콜

IPv4  
인터넷에서 사용되는 패킷 교환 네트워크상에서 데이터를 교환하기 위한 32bit 주소체계를 갖는 네트워크 계층의 프로토콜
+ 32bit (8bit씩 네 부분으로 나누어 표현가능) 🔴
+ 가변헤더
+ IPSec 프로토콜 별도 제공

IPv6 🔴  
인터넷 프로토콜 스택 중 네트워크 계층의 프로토콜로서 버전 6 인터넷 프로토콜로 재정의된 차세대 인터넷 프로토콜
+ 128bit 🔴
+ 고정헤더
+ 활장기능에서 보안 기본 제공

L2TP 🔴
+ 2 계층(데이터링크 계층)에서 구현되는 터널링 기술 중 하나
+ L2F와 PPTP가 결합된 프로토콜로 VPN과 인터넷 서비스 제공자(ISP)가 이용
+ IPsec을 함께 사용하면 PPTP보다 훨씬 안전하지만 보안보다 익명화에 더 적합

서킷 교환 방식
+ 전송경로를 설정한 뒤 데이터를 송수신하는 방식
+ 송수신 측 모두 데이터 교환 준비가 완료되어야 하고 회선이 독점되어 있음
+ 영상, 비디오

패킷 교환 방식
+ 데이터를 패킷 단위로 보내는 방식
+ 회선 효율이 우수하고 비동기 전송이 가능
+ 실시간 전송에 부적합하며 네트워크 지연이 발생
+ 이메일, 메시지 등
  + 가상회선 방식 🔴🔴
    + 목적지 호스트와 미리 연결 후 통신하는 연결형 교환 방식
    + 처음 패킷으로 최적의 경로를 고정하고 경로가 고정되면 그 다음은 패킷으로 나누어 고속으로 전송
  + 데이터그램 방식 🔴🔴
    + 헤더를 붙여서 개별적으로 전달하는 비연결형 교환 방식
    + 짧은 메시지의 패킷들을 전송할 때 효과적이고 재정렬 기능이 필요

**라우팅 프로토콜**  
데이터는 송신 측으로부터 수신 측까지 데이터를 전달하는 과정에서 다양한 물리적인 장치들을 거침  
목적지가지의 최적 경로를 산출하기 위한 방법

알고리즘
+ 거리 벡터 알고리즘
  + 인접 라우터와 정보를 공유하여 목적지까지의 거리와 방향을 결정하는 라우팅 프로토콜 알고리즘
+ 링크 상태 알고리즘(OSPF,Open Shortest Path First) 🔴
  + 링크 상태 정보를 모든 라우터에 전달하여 최단 경로 트리를 구성하는 라우팅 알고리즘
  + 다익스트라 알고리즘을 사용
  + 라우틱 메트릭 지정
    + 최소 지연, 최대 처리량 등 관리자가 라우팅 메트릭 지정
  + AS 분할 사용
    + 자치 시스템을 지역으로 나누어 라우팅을 효과적으로 처리
  + 홉 카운트 무제한
    + 홉 카운트에 제한이 없다.

종류
+ RIP
  + 최초의 라우팅 프로토콜
  + 거리 벡터 알고리즘 활용
+ IGP(Interior Gateway Protocol)
  + 라우터로 상호 접속이 되어있는 여러 개의 네트워크 집합으로 도메인 혹은 자율시스템(Autonomous System, AS)이라고 한다.
  + 같은 도메인 내에 존재하는 라우터는 도메인 내부 라우터가 되고 도메인 외부에 존재하는 라우터는 도메인 외부 라우터가 되는데, 여기서 도메인 내부 경로 설정을 가르킨다.
  + RIP 문제점 개선을 위해 시스코에서 개발
  + 네트워크 상태를 고려하고 라우팅
+ OSPF(Open Shortest Path First)
  + IP 라우팅 프로토콜의 한 종류로써 RIP(routing information protocol)보다 규모가 큰 네트워크에서도 사용할 수 있다.
  + 규모가 크고 복잡한 TCP/IP 네트워크에서 RIP의 단점을 개선한 라우팅 프로토콜로써 RIP에 비해 자세한 제어가 가능하고, 관리 정보의 트래픽도 줄일 수 있다.
  + 링크 상태 알고리즘 사용
  + 발생한 변경 정보에 대해 RIP보다 빠른 업데이트
+ EGP(Exterior Gateway Protocol)
  + 시스템 사이에 경로 설정 정보 등을 교환하기 위해 사용하는 프로토콜
  + 다른 도메인 사이에 라우팅 시 정리된 관리가 거의 없고 많은 경우에 신용도가 매우 낮아 빠른 수행보다는 보안과 제어가 본래의 목적이다.
+ BGP(Border Gateway Protocol)
  + 규모가 큰 네트워크의 상호 연결
  + 서로 다른 자율 시스템(AS)의 라우터 간에 라우팅 정보를 교환하는 데 사용되는 외부 게이트웨이 프로토콜(EGP)이다.
  + 각 목적지에 대한 전체 경로가 포함되며, 다른 시스템과 교환하는 네트워크 도달 가능성 정보의 데이터베이스를 유지한다.
  + 네트워크 도달 가능성 정보를 사용하여 AS 연결 그래프를 구성하며, 이를 통해 라우팅 루프를 제거하고 AS 수준에서 정책 결정을 실행할 수 있다.

**네트워크 주소 분할**
```
🔴
첫번째 네트워크 주소가 192.168.1.0/24일때 FLSM 3개로 분할했을때 
두번째 네트워크 브로드캐스드 IP를 10진수로 변환한 값을 작성하시오.
// 192.168.1.127
```
+ FLSM는 고정된 크기도 똑같이 나누는 것을 말한다.
+ ```/24```는 앞에서부터 24개의 1을 의미하므로 마지막 8비트만을 변경해서 IP 주소로 사용이 가능하다.
+ 즉, 마지막 자리에 0~255의 256개의 IP주소가 생성될 수 있다.
+ ```11111111 11111111 11111111 11000000``` 이지만 마지막 ```11000000```에서 FLSM을 3개로 분할하기 때문에 ```2<super>2</super>```가 되어 앞에 두 자리를 막아주기 때문에 64개씩 나누면 된다.
+ ```192.168.1.0 ~ 192.168.1.63``` 첫 번째 그룹이 이렇게 정해진다고 했을 때, 맨 앞은 네트워크 ID 주소이고 뒤에 주소는 브로드캐스트 IP 주소가 된다.
+ 따라서 두 번째 그룹의 브로드캐스트 주소는 ```192.168.1.127```이 된다.

```
🔴
IP 주소가 139.127.19.132이고 서브넷마스크 255.255.255.192일 때 아래의 답을 작성하시오.
// (1) 괄호안에 들어갈 네트워크 주소 : 139.127.19.(128)
// (2) 해당 네트워크 주소와 브로드캐스트 주소를 제외한 호스트 개수 : 62
```
+ 네트워크 주소는 AND 연산을 통해 구한다. IP 주소와 서브넷 마스크의 ID를 AND 연산하면, 어차피 서브넷 마스크는 255 이니까, HOST ID 빼고 IP 주소를 따라간다.
+ 즉, 뒤에 수를 기준으로 보면, IP 주소는 132이므로 ```10001000```, 서브넷마스크는 192이므로 ```1100000000```이 된다.
+ 따라서 AND 연산하면, ```10000000``` = 128 이 네트워크 주소 마지막 수가 된다.
+ 호스트 개수는 서브넷을 구분하는 두 자리를 제외하고 6비트로 구분되므로 2<super>6</super> - 2 = ```62``` 이다.
+ 여기서 네트워크 주소와 브로드캐스트 주소를 제외하기 때문에 2를 빼서 계산한다.


<br>

### 11-4. 기본 개발환경 구축하기
**개발환경 인프라 구성방식**
+ 온프레미스 방식
  + 외부 인터넷망이 차단된 상태에서 인트라넷망만을 활용하여 개발환경을 구축하는 방식
+ 클라우드 방식
  + 아마존, 구글, 마이크로소프트 등 클라우드 공급 서비스를 하는 회사들의 서비스를 임대하여 개발환경을 구축하는 방식
+ 하이브리드 방식
  + 온프레미스 + 클라우드

<br>

****
**용어정리**

| 용어                          | 설명                                                                                    |
|-----------------------------|---------------------------------------------------------------------------------------|
| MMU(Memory Management Unit) | CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 하드웨어 부품으로 가상 메모리 주소를 실제 메모리 주소로 변환하는 장치                    |
| 프로세스                        | 일반적으로 CPU에 의해 처리되는 프로그램으로 현재 실행 중인 프로그램                                               |
| 문맥교환                        | CPU가 현재 실행하고 있는 프로세스의 문맥 상태를 프로세스 제어블록에 저장하고 다음 프로세스의 PCB로부터 문맥을 복원하는 작업을 문맥교환이라고 한다. |
| 기아현상                        | 시스템 부하가 많아 준비 큐에 있는 낮은 등급의 프로세스가 무한정 가다리는 현상                                          |
| 선언                          | 변수에 이름, 데이터 타입 등의 속성을 부여하는 작업                                                         |
| 온톨로지                        | 실세계에 존재하는 모든 개념들과 개념들의 속성, 그리고 개념들 간의 관계 정보를 컴퓨터가 이해할 수 있도록 서술해 놓은 지식베이스              |
| 시맨틱 웹                       | 온톨로지를 활용하여 서비스를 기술하고, 온톨로지의 의미적 상호 운용성을 이용해서 서비스 검색, 조합, 중재 기능을 자동화하는 웹               |
| 멀티캐스트                       | 하나 이상의 송신자들이 특정한 하나 이상의 수신자들에게 데이터를 전송하는 방식으로 인터넷 화상 회의 등에서 응용                        |
| 유니캐스트                       | 고유 주소로 식별된 하나의 네트워크 목적지에 1:1로 트래픽 또는 메시지를 전송하는 전송 기술                                  |
| 브로드캐스트                      | 하나의 송신지가 같은 서브 네트워크 상의 모든 수신자에게 데이터를 전송하는 기술                                          |
| 애니캐스트                       | 단일 송신자로부터의 데이터그램들을 토플로지 상의 잠재적인 수신자 그룹 안에서 가장 가까운 노드로 연결시키는 전송 기술                     |

<br><br>

## 12장. 제품 소프트웨어 패키징
**디지털 저작권 관리**
+ 콘텐츠 제공자: 저작권자
+ 콘텐츠 분배자: 암호화된 콘텐츠 제공
+ 패키저: 콘텐츠를 메타 데이터와 함께 배초 가능한 단위로 묶는 기능
+ 보안 컨테이너: 원본을 안전하게 유통하기 위한 전자적 보안 장치
+ DRM 컨트롤러: 배포된 콘텐츠의 이용권한을 통제
+ 클리어링 하우스: 키 관리 및 라이선스 발급 관리

**릴리즈 노트**
+ 헤더 🔴: 문서이름, 제품이름, 버전, 릴리즈 날짜, 참고 날짜, 노트 버전 등의 정보
+ 개요: 제품 및 변경에 대한 간략한 전반적 개요
+ 목적: 릴리스 버전의 새로운 기능목록과 릴리스 노트의 목적에 대한 개요, 버그 수정 및 새로운 기능 기술
+ 이슈 요약: 버그의 간단한 설명 또는 릴리즈 추가 항목 요약
+ 재현 항목: 버그 발견에 따른 재현 단계 기술
+ 수정/개선 내용
+ 사용자 영향도
+ 소프트웨어 지원 영향도
+ 노트
+ 면책 조항
+ 연락 정보

<br>

****
**용어정리**

| 용어                       | 설명                                                                                                                                  |
|--------------------------|-------------------------------------------------------------------------------------------------------------------------------------|
| 모듈                       | 소프트웨어 설계에서 기능 단위로 분해하고 추상화되어 재사용 및 공유 가능한 수준으로 만들어진 단위                                                                              |
| ISAM                     | 자료 내용은 주 저장부, 자료의 색인은 자료가 기록된 위치와 함께 색인부에 기록                                                                                        |
| VSAM                     | 대형 운영체제에서 사용되는 파일 관리시스템                                                                                                             |
| 컴포넌트 저장소                 | 인증을 받은 컴포넌트를 등록하는 저장소로서 사용자는 저장소를 통해 손쉽게 컴포넌트를 이용                                                                                   |

<br><br>

## 13장. 기타 추가내용
**애플리케이션 성능 측정 지표**
+ 처리량
  + 애플리케이션이 주어진 시간에 처리할 수 있는 트랜잭션 수
  + 웹 애플리케이션의 경우 시간당 페이지 수로 표현
+ 응답시간 🔴
  + 사용자 입력이 끝난 후, 애플리케이션의 응답 출력이 개시될 때까지의 시간
  + 애플리케이션의 경우 메뉴 클릭시 해당 메뉴가 나타나기까지 걸리는 시간
+ 경과시간 🔴
  + 애플리케이션에 사용자가 요구를 입력한 시점부터 트랜잭션을 처리 후 그 결과의 출력이 완료할 때까지 걸리는 시간
+ 자원 사용률
  + 애플리케이션이 트랜잭션을 처리하는 동안 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량

**비즈니스 연속성 계획(BCP)**
+ BIA(Business Impact Analysis)
  + 장애나 재해로 인해 운영상의 주요 손실을 볼 것을 가정하여 시간 흐름에 따른 영향도 및 손실평가를 조사하는 BCP를 구축하기 위한 비즈니스 영향 분석
+ RTO(Recovery Time Objective), 재해 복구 시간 🔴
  + 비상상태 또는 업무중단 시점부터 업무가 복구되어서 다시 정상 가동될 때까지의 시간을 의미하는 용어
+ RPO(Recovery Point Objective)
  + 업무중단 시점부터 데이터가 복구되어 다시 정상가동될 때 데이터의 손실허용 시점
  + 재해시 복구 목표 지점의 선정
+ DRP(Diaster Recovery Plan)
  + 재난으로 장기간에 걸쳐 시설의 운영이 불가능한 경우를 대비한 재난 복구 계획
+ DRS(Disaster Recovery System)
  + 재해복구 계획의 원활한 수행을 지원하기 위하여 평상시에 확보하여 두는 인적, 물적 자원 및 이들에 대한 지속적인 관리체계가 통합된 재해복구센터

**소프트웨어 개발방법론**
+ 구조적 방법론
  + 전체 시스템을 기능에 따라 나눠 개발하고 이를 통합하는 분할과 정복 접근 방식의 방법론
+ 정보공학 방법론
  + 정보 시스템 개발에 필요한 관리 절차와 작업 기법읠 체계화한 방법론
+ 객체지향 방법론
  + 객체라는 기본 단위로 시스템을 분석 및 설계하는 방법론
+ 컴포넌트 기반 방법론
  + 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
+ 애자일 방법론 🔴
  + 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템 개발할 수 있는 신속 적응적 경량 개발방법론
+ 제품 계열 방법론
  + 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론

**객체지향 설계 원칙 (= SOILD)**
> 5대 설계원칙: SRP, OCP, LSP, ISP, DIP

SRP(Single Responsibility Principle), 단일 책임 원칙
+ 한 클래스는 하나의 책임만 가져야 한다.

OCP(Open/Closed principle), 개방-폐쇄 원칙
+ 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.

LSP(Liskov Substitution Principle), 리스코프 치환 원칙
+ 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

ISP(Interface Segregation Principle), 인터페이스 분리 원칙 🔴
+ 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
+ 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다.
+ 큰 덩어리의 인터페이스들은 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다.
+ 로직이 바뀌어도 다른 메서드는 영향을 받지 않도록 해야 한다.
+ 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다.
+ 인터페이스를 클라이언트에 특화되도록 분리시켜 설계하는 원칙
+ 예를 들어, 복합기 클래스의 모든 기능을 클라이언트가 동시에 사용하는 경우는 거의 없으므로 필요시 프린트, 팩스, 복사기 클라이언트 중 하나의 기능만 이용할 수 있도록 설계하는 경우

DIP(Dependency Inversion Principle), 의존관계 역전 원칙
+ 프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다. - 의존성 주입

**디자인 패턴**  
소프트웨어 설계에서 자주 발생하는 문제에 대한 일반적이고 반복적인 해결 방법
모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결방식 또는 예제를 의미함

**GoF(Gang of Four) 디자인 패턴**  ```생구행```

생성 패턴  
클래스/객체 생성과 참조과정을 정의하는 패턴
> Abstract Factory, Builder, Factory Method, Prototype, Singleton

+ ```Abstract Factory``` 패턴, 추상화 패턴
  + 구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 연관/의존하는 객체들의 그룹으로 생성하려 추상적으로 표현함
+ ```Builder``` 패턴
  + 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성함. 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어낼 수 있음
+ ```Factory Method``` 패턴 🔴
  + 가상 생성자 패턴으로 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화 한 패턴으로 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당함.
  + 부모(상위) 클래스에 알려지지 않은 구체 클래스를 생성하는 패턴이며, 자식(하위) 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴이기도 하다. 부모(상위) 클래스 코드에 구체 클래스 이름을 감추기 위한 방법으로도 사용한다.
+ ```Prototype``` 패턴
  + 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴으로 일반적인 방법으로 객체를 생성하며 비용이 큰 경우 주로 이용함
+ ```Singleton``` 패턴
  + 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없고 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화할 수 있음

구조 패턴  
구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만든 패턴
> Adapter, Bridge, Proxy, Composite, Decorator, Facade, Flyweight

+ ```Adapter``` 패턴
  + 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴으로, 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용함
+ ```Bridge``` 패턴 🔴
  + 기능을 처리하는 클래스와 구현을 담당하는 추상 클래스로 구별한다.
  + 구현뿐 아니라 **추상화도 독립적 변경이 필요할 때** 브리지 패턴을 사용한다.
  + 기존 시스템에 부수적인 새로운 기능들을 지속적으로 추가할 때 사용하면 유용하며, 새로운 인터페이스를 정의하여 기존 프로그램의 변경 없이 기능을 확장할 수 있다.
+ ```Composite``` 패턴
  + 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴으로, 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있음
+ ```Decorator``` 패턴
  + 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴으로, 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현함
+ ```Facade``` 패턴
  + 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴으로, 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요함
+ ```Flyweight``` 패턴
  + 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴으로, 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있음
+ ```Proxy``` 패턴 🔴
  + 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴으로 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용함

행동/행위 패턴 🔴🔴
> Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Observer, State, Strategy, Visitor

+ ```Chain of Responsibility``` 패턴
  + 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴으로, 요청을 처리할 수 있는 각 객체들이 고리로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감
+ ```Command``` 패턴
  + 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴으로, 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함
+ ```Interpreter``` 패턴
  + 언어에 문법 표현을 정의하는 패턴으로, SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용함
+ ```Iterator``` 패턴
  + 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴으로, 내부 표현 방법의 노출 없이 순차적인 접근이 가능함
+ ```Mediator``` 패턴
  + 수 많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴으로, 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음
+ ```Mememto``` 패턴
  + 특정 시점에서의 객체 내부 상태의 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴으로, [Ctrl]+[Z]와 같은 되돌리기 기능을 개발할 때 주로 이용함
+ ```State``` 패턴
  + 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴으로 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리함
+ ```Observer``` 패턴 🔴🔴
  + 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달해주는 패턴이다.
  + 일대다 관계를 가지며, 주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용한다.
+ ```Strategy``` 패턴
  + 동일한 계열의 알고리즘을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴으로 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능함
+ ```Template Method``` 패턴
  + 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화는 구조의 패턴으로, 유사한 서브 클래스를 묶에 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌
+ ```Visitor``` 패턴
  + 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴으로, 분리된 처리 기능은 각 클래스를 방문하여 수행함

**리눅스 명령어**
+ 소유권 관련 명령어
  ```
  chown            // 파일이나 디렉터리의 사용자 소유권과 그룹 소유권을 변경하는 명령어
  chgrp            // 파일이나 디렉터리의 그룹 소유권을 변경하는 명령어
  ```
  + ```chgrp -R kait data/```: data 디렉터리의 하위 디렉터리를 포함해서 디렉터리 내부의 모든 파일 및 디렉터리의 그룹 소유권을 kait로 변경하는 과정
+ 허가권 관련 명령어
  ```
  // 허가권은 읽기, 쓰기, 실행으로 구분
  chmod            // 파일이나 디렉터리의 허가권을 변경하는 명령어
  umask            // 새로 생성되는 파일이나 디렉터리의 기본 허가권을 지정하는 명령어
  ```
  ```shell
  chmod 751 a.txt 🔴
  // 사용자에 대한 읽기(4), 쓰기(2), 실행(1) 권한
  // 그룹에 대한 읽기(4), 실행(1) 권한
  // 그 외에 대한 실행(1) 권한
  ```

**리펙토링**  
리펙토링은 소프트웨어 모듈의 외부적 기능은 수정하지 않고 내부적으로 구조, 관계 등을 단순화하여 소프트웨어의 유지보수성을 향상시키는 기법

리펙토링의 목적 🔴  
복잡한 코드의 단순화, 소스의 가독성을 통해 유지보수성 향상, 생산성 향상, 품질 향상 등

**관계해석** 🔴
+ 관계 데이터의 연산을 표현하는 방법으로 원하는 정보를 정의할 때는 계산 수식을 사용한다.
+ 원하는 정보와 그 정보는 어떻게 유도하는가를 기술하는 **비절차적인 언어**다.
+ 수학의 predicate calculus에 기반을 두고 있으며, 관계 데이터 모델의 제안자인 codd가 수학에 가까운 기반을 두고 특별히 관계 데이터베이스를 위해 제안해서 탄생
+ ```튜블 관계해석```과 ```도메인 관계해석```이 있다.

**관계대수**  
관계대수는 **절차적 언어**로 어떻게 데이터를 처리할지를 효율적으로 정하는 데 사용되며, 관계해석은 어떤 데이터가 필요한지를 더욱 간단하게 정의하는 데 사용됩니다.


| 연산자    | 기호   | 설명                                  |
|----------|------|-------------------------------------|
| SELECT   | σ    | 릴레이션 R에서 조건을 만족하는 튜플 반환             |
| PROJECT  | π 🔴🔴 | 릴레이션 R에서 주어진 속성들의 값만으로 구성된 튜플 반환    |
| JOIN     | ▷◁ 🔴  | 공통 속성을 이용해 R과 S의 튜플을 연결해 만들어진 튜플 반환 |
| DIVISION | ÷ 🔴 | 릴레이션 S의 모든 튜플과 관련 있는 R의 튜플 반환       |

| 연산자                     |기호 | 연산자                     | 기호 |
|-------------------------|----|---------------------------|-----|
| UNION (합집합)             | ∪ 🔴 | OR                        | ∨   |
| INTERSECTION (교집합)      | ∩  | AND                       | ∧   |
| DIFFERENCE (차집합)        | - 🔴 | NOT                       | ￢  |
| CARTESIAN PRODUCT (교차곱) | X 🔴 | FOR ALL (전칭 정량자)       | ∀   |
|                         |    | THERE EXISTS (존재 정량자)  | ∃   |

+ 프로젝트(PROJECT)는 주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만다는 연산

```
// 관계대수식
π ttl (EMPLOYEE)
```
+ EMPLOYEE 테이블에서 ttl 속성의 열을 출력 → 수직 부분집합

**식별자 표기법**
+ 카멜 표기법 ```inputFunction```
+ 파스칼 표기법 ```InputFunction```
+ 스네이크 표기법 ```input_function```
+ 헝가리안 표기법 ```nScore``` 🔴
  + 식별자 표기시 두어에 자료형을 붙이는 표기법
  + 식별자 표기시에 int는 ```n```, char는 ```c```, 문자열은 ```s```를 붙임

**NAT(Network Address Transformantion)** 🔴  
보통 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP주소를 사용하여 인터넷에 접속하기 위해서 사용
+ Static NAT
  + 사설 IP주소와 공인 IP주소가 1:1로 연결되는 구성
+ Dynamic NAT
  + 사설 IP와 공인 IP 주소가 N:1 또는 N:M으로 연결되는 구성
  + 사설 IP를 가진 장치의 요청시 동적으로 공인 IP주소 Table에 할당하여 인터넷과 연결하는 방식

**하둡** 🔴  
오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼으로 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발된 자바 소프트웨어 프레임워크로 구글, 야후 등에 적용한 기술  
빅데이터 기술로 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼
+ 하둡 분산 파일 시스템(HDFS, Hadoop Distributed File System)
  + 대용량 파일 을 분산된 서버에 저장하고, 그 저장된 데이터를 빠르게 처리할 수 있게 하는 하둡 분산파일 시스템
+ 맵리듀스(Map Reduce)
  + 대용량 데이터 세트를 분산 병렬 컴퓨팅에서 처리하거나 생성하기 위한 목적으로 만들어진 소프트웨어 프레임워크
  + 모든 데이터를 키-값 쌍으로 구성, 데이터를 분류

**서버 접근통제 유형**
+ 임의적 접근통제(DAC, Discretionary Access Control) 🔴
  + 시스템에 대한 접근을 사용자/그룹의 ```신분``` 기반으로 제한하는 방법
  + DAC에서 사용하는 사용자는 자원과 관련된 ACL(Access Control List)이 수정됨으로써 자원에 대한 권한을 부여
+ 강제적 접근통제(MAC, Mandatory Access Control)
  + 시스템 정보의 ```허용등급```을 기준으로 사용자가 갖는 접근 허가 권한에 근거하여 시스템에 대한 접근을 제한하는 방법
+ 역할 기반 접근통제(RBAC, Role Based Access Control)
  + 중앙 관리자가 사용자와 시스템의 상호관계를 통제하며 조직 내 맡은 ```역할```에 기초하여 자원에 대한 접근을 제한하는 방법

**️RAID(Redundant Array of Independent Disks)**
+ 여러 개의 물리적인 하드디스크를 하나의 논리 디스크로 인식하게 만드는 기술
+ 중요한 데이터를 가지고 있는 서버에 주로 사용, 여러 개의 하드디스크에 동일한 데이터를 다른 위치에 중복해서 저장하는 기술
+ 하드웨어 RAID, 소프트웨어 RAID
+ 레벨에 따라 데이터를 저장하는 방법이 상이
+ 여러 개의 하드디스크로 디스크 배열을 구성하여 파일을 구성하고 있는 데이터 블록들을 서로 다른 디스크들에 분산 저장할 경우, 그 블록들을 여러 디스크에서 동시에 읽거나 쓸 수 있으므로 디스크의 속도가 매우 향상되는데, 이 기술을 RAID라고 함

RAID 단계
+ RAID 0: ```스트라이핑```을 이용, 논리적으로 연속된 여러 개의 물리적인 디스크 드라이브에 나누어 저장하는 기술 🔴
  + 구성된 디스크 중 한 개라도 오류가 발생하면 데이터 복구가 불가한 RAID 구성법
  + 디스크 오류 대처와 가장 거리가 멀다.
+ RAID 1: 두 개 이상의 디스크를 ```미러링```으로 하나같이 사용, 복사본을 만드는 기술
+ RAID 0+1: 최소 4개 이상의 디스크에서 먼저 2개씩 RAID 0으로 묶고, 이것을 다시 RAID 1으로 결합하는 방식
+ RAID 2: 데이터 오류 검출을 위한 ```해밍코드```를 사용, 최근 디스크에는 기본적으로 탑재한 기술로 거의 사용되지 않음
+ RAID 3/4: 하나의 디스크를 ```패리티``` 정보를 위해 사용하고 나머지 디스크에 데이터를 균등하게 분산 저장하는 방식
  + 패리티: 정보의 전달 과정에서 오류가 생겼는지를 검사하기 위해 추가되는 비트
  + RAID 0과 유사하나 쓰기는 패리티 처리로 인해 일부 성능 저하
  + RAID 4는 RAID 3과 달리 모든 블록이 균등하게 저장되지 않는다. ```블록 단위 분산 저장```
  + 병목 현상이 발생하면 성능 저하가 발생할 우려가 있다.
+ RAID 5: 3개 이상의 디스크를 사용하여 하나의 디스크처럼 사용하고, ```각각의 디스크에 패리티 정보```를 가지고 있는 방식
  + 별도의 패리티 디스크를 사용하지 않기 때문에 병목 현상이 발생하지 않는다.
+ RAID 6: 하나의 패리티를 두 개의 디스크에 분산 저장
  + 패리티를 이중으로 저장하므로 두 개의 디스크에 오류가 발생해도 복구 가능
  + 느려질 수 있으나, 안정성은 높아진다.

HTTP 🔴
+ 인터넷에서, 웹 서버와 사용자의 인터넷 브라우저 사이에 문서/멀티미디어를 전송하기 위해 사용되는 통신 규약을 말한다.
+ 인터넷에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신규약이다. 이 규약에 맞춰 개발해서 서로 정보를 교환할 수 있게 되었다.

Hypertext 🔴
+ ```Hypertext```에서 다른 문서 간의 연결을 링크(Link)라고 한다.
+ 문자, 그래픽, 음성 및 영상을 하나의 연상 거미집(Web of Association)과 같이 서로 연결시켜, 제시된 순서에 관계없이 이용자가 관련된 정보를 검색할 수 있도록 하는 정보 제공 방법이다.
+ 즉, 한 페이지에서 링크된 순서에 상관없이 사용자들이 원하는 정보를 클릭함으로써 원하는 정보에 쉽게 접근하는 방식을 말한다.

HTML 🔴
+ 웹 페이지 표시를 위해 개발된 지배적인 마크업 언어다. 또한, 제목, 단락, 목록 등과 같은 본문을 위한 구조적 의미를 나타내는 것뿐만 아니라 링크, 인용과 그 밖의 항목으로 구조적 문서를 만들 수 있는 방법을 제공한다.

<br>

****
**용어정리**

| 용어                                                          | 설명                                                                                                                                                                                                               |
|-------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| LOD(Linked Open Data) 🔴                                    | 웹상에 존재하는 데이터를 개별로 식별하고 각 URI에 링크정보를 부여함으로써 상호 연결된 웹을 지향하는 데이터<br> HTTP, RDF, URI 등 웹 표준을 활용해서 데이터를 누구나 자유롭게 활용하고 재생산할 수 있도록 개방한 데이터                                                                              |
| 생성자 🔴                                                      | 해당 클래스의 객체가 생성될 때 자동으로 호출되는 특수한 종류의 메서드                                                                                                                                                                          |
| 블록체인 🔴                                                     | 분산 컴퓨팅 기술기반의 데이터 위변조 방지 기술로 P2P 방식을 기반으로 하여 소규모 데이터들이 연결되어 형성된 '블록'이라는 분산 데이터 저장 환경에 관리 대상 데이터를 저장함으로써 누구도 임의로 수정할 수 없고 누구나 변경의 결과를 열람할 수 있게끔 만드는 기술                                                             |
| 잠금(로킹, Locking) 🔴                                          | 같은 자원을 액세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장하는 직렬화 기법                                                                                                                                        |
| ISMS (Information Security Management System), 정보보호 관리체계 🔴 | 정부에서 정한 인증기관 및 심사기관에서 기업이 주요 정보자산을 보호하기 위해 수립/관리/운영하는 정보보호 관리체계가 인증 기준에 적합한지를 심사하여 인증을 부여하는 제도                                                                                                                   |
| 사회공학 🔴                                                     | 보안학적 측면에서 기술적인 방법이 아닌 사람들간의 기본적인 신뢰를 기반으로 사람을 속여 비밀 정보를 획득하는 기법<br> ```스피어 피싱(Spear Phishing)```: 사회공학의 한 기법으로 특정 대상을 선정한 후 그 대상에게 일반적인 이메일로 위장한 메일을 지속적으로 발송하여, 발송 메일의 본문 링크나 첨부된 파일을 클릭하도록 유도해 사용자의 개인 정보를 탈취함 |
| 다크 데이터 🔴                                                   | 빅데이터(Big Data)와 비슷하면서도 구조화돼 있지 않고, 더는 사용하지 않는 ‘죽은’ 데이터를 의미<br> 일반적으로 정보를 수집해 저장한 이후 분석이나 특별한 목적을 위해 활용하는 데이터가 아니며, 저장공간만 차지하고 이러한 이유로 심각한 보안 위험을 초래할 수 있음                                                        |
| 타이포스쿼팅 Typosquatting 🔴                                     | 네티즌들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 이와 유사한 유명 도메인을 미리 등록하는 일로, URL 하이재킹이라고도 함                                                                                                                     |
| APT(Advanced Persistent Treats), 지능형 지속위험                   | 다양한 IT 기술과 방식들을 이용해 조직적으로 특정 기업이나 조직 네트워크에 침투해 활동 거점을 마련한 뒤 때를 기다리면서 보안을 무력화시키고 정보를 수집한 다음 외부로 빼돌리는 형태의 공격                                                                                                       |
| watering hole 🔴                                            | 이 공격은 APT 공격에서 주로 쓰이는 공격으로, 공격 대상이 방문할 가능성이 있는 합법적인 웹 사이트를 미리 감염시킨 뒤, 잠복하고 있다가 공격 대상이 방문하면 대상의 컴퓨터에 악성코드를 설치하는 방식                                                                                                |
| Trustzone 🔴                                                | 프로세서(processor) 안에 독립적인 보안 구역을 따로 두어 중요한 정보를 보호하는 ARM사에서 개발한 하드웨어 기반의 보안 기술로 프로세서(processor) 안에 독립적인 보안 구역을 별도로 하여, 중요한 정보를 보호하는 하드웨어 기반의 보안 기술                                                                  |
